<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>NOI2014 购票</title>
  <link rel="stylesheet" type="text/css" id="frame_style" href="../css/frame_style1.css">
  <link rel="stylesheet" type="text/css" id="Markdown_style" href="../css/Markdown_style.css">
  <script type="text/javascript" src="../jscode/frame.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="stylesheet" href="https://ziyuan.fenxianglu.cn/js/highlight/styles/default.css">
  <script src="https://ziyuan.fenxianglu.cn/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
</head>
<body>
  <div class="main">
    <div class="head">
      <div class="title1">
        <a href="../index.html">wjh15101051's space</a>
      </div>
      <div class="title2">
        卧薪尝胆，厚积薄发。
      </div>
    </div>
    <div id="middle_blogfile">
      <div class="blog_blogfile">
        <div class="blogfile_title">
            NOI2014 购票
        </div>
        <div class="blogfile_stitle">
          <img src="http://pic.yupoo.com/wjh15101051/1e0e1b3a/118165c5.jpg">
          Date: Sat Dec 22 20:10:47 CST 2018
          <img src="http://pic.yupoo.com/wjh15101051/2ea96b56/7882c4ab.png">
          In Category:
          <a href="../categories/NoCategory.html">NoCategory</a>
        </div>
        <div class="blogfile_content">
<div class = "MarkdownCommonContent">
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Description：
</h2>
</div>
<div class = "MarkdownCommonContent">
给一棵树，每个点都想走到根，每个点
$k$
可以走到他的一个祖先
$anc$
要求
$dis(k,anc)\leqslant l_k$
，花费
$s_k\times dis(k,anc)+b_k$
的花费，求每个节点到根的花费。
</div>
<div class = "MarkdownCommonContent">
$1\leqslant n\leqslant 2\times10^5$
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Solution1：
</h2>
</div>
<div class = "MarkdownCommonContent">
首先上面那个式子显然是可以斜率优化的，即
$f[k]=\min(f[anc]+s_k\times dep[k]-s_k\times dep[anc]+b_k)(dep[k]-dep[anc]\leqslant l_k)$
，那么如果没有那个距离限制我们就可以在
$dfs$
的栈上维护一个凸包，然后每次在凸包上二分最优解，因为
$-s_k$
不单调，但是由于距离的限制，在之前一定不会成为最优解的在之后可能成为决策点，所以我们就必须换一种做法。
</div>
<div class = "MarkdownCommonContent">
先考虑在序列上怎么做，可以使用
$cdq$
分治，我们知道
$cdq$
分治的一个重要作用就是去掉左右区间内部的时间顺序，那么我们就可以按右区间每个点能延伸到的左端点从右向左排序，也就是说在左区间中的覆盖范围逐渐增大，然后逐步构造出左区间形成的凸包，每次让右区间在对应部分二分最优解并随着覆盖范围逐渐在凸包中插入点即可，由于
$dep[anc]$
是单调的所以用单调栈维护凸包就行了。
</div>
<div class = "MarkdownCommonContent">
考虑怎么把它扩展到树上，发现分治实际就是找中点然后分为两部分，那么对于树我们可以利用点分治，把整棵树分为从根到重心和重心的子树，然后像在序列上一样用从根到重心的值更新重心的子树的值就行了。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Code1：
</h2>
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;vector&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 200010<br />
typedef long long ll;<br />
struct edge<br />
{<br />
    int to,nxt;<br />
    ll v;<br />
}e[MAXN &lt;&lt; 1];<br />
int edgenum = 0;<br />
int lin[MAXN] = {0};<br />
void add(int a,int b,ll c)<br />
{<br />
    e[++edgenum] = (edge){b,lin[a],c};lin[a] = edgenum;<br />
    e[++edgenum] = (edge){a,lin[b],c};lin[b] = edgenum;<br />
    return;<br />
}<br />
ll p[MAXN],q[MAXN],g[MAXN];<br />
int fa[MAXN],anc[MAXN];<br />
ll dep[MAXN];<br />
int stack[MAXN],top = 0;<br />
void dfs(int k,ll depth)<br />
{<br />
    dep[k] = depth;<br />
    stack[++top] = k;<br />
    int l = 1,r = top,mid;<br />
    while(l &lt; r)<br />
    {<br />
        mid = ((l + r) &gt;&gt; 1);<br />
        if(dep[k] - dep[stack[mid]] &lt;= g[k])r = mid;<br />
        else l = mid + 1;<br />
    }<br />
    anc[k] = stack[l];<br />
    for(int i = lin[k];i != 0;i = e[i].nxt)<br />
    {<br />
        if(dep[e[i].to] == 0)<br />
        {<br />
            fa[e[i].to] = k;<br />
            dfs(e[i].to,depth + e[i].v);<br />
        }<br />
    }<br />
    --top;<br />
    return;<br />
}<br />
int s,root,siz[MAXN],d[MAXN];<br />
#define INF 0x3f3f3f3f<br />
bool vis[MAXN];<br />
void getsiz(int k,int fa)<br />
{<br />
    siz[k] = 1;<br />
    for(int i = lin[k];i != 0;i = e[i].nxt)<br />
    {<br />
        if(e[i].to == fa || vis[e[i].to])continue;<br />
        getsiz(e[i].to,k);<br />
        siz[k] += siz[e[i].to];<br />
    }<br />
    return;<br />
}<br />
void getroot(int k,int fa)<br />
{<br />
    siz[k] = 1;d[k] = 0;<br />
    for(int i = lin[k];i != 0;i = e[i].nxt)<br />
    {<br />
        if(e[i].to == fa || vis[e[i].to])continue;<br />
        getroot(e[i].to,k);<br />
        siz[k] += siz[e[i].to];<br />
        d[k] = max(d[k],siz[e[i].to]);<br />
    }<br />
    d[k] = max(d[k],s - siz[k]);<br />
    if(d[k] &lt; d[root])root = k;<br />
    return;<br />
}<br />
struct state{int top,id;}t[MAXN];<br />
bool cmp_top(state a,state b){return dep[a.top] &gt; dep[b.top];}<br />
int tot = 0;<br />
void get(int k,int fa)<br />
{<br />
    t[++tot] = (state){anc[k],k};<br />
    for(int i = lin[k];i != 0;i = e[i].nxt)<br />
    {<br />
        if(vis[e[i].to] || e[i].to == fa)continue;<br />
        get(e[i].to,k);<br />
    }<br />
    return;<br />
}<br />
int hull[MAXN],htop = 0;<br />
ll f[MAXN];<br />
ll x(int k){return dep[k];}<br />
ll y(int k){return f[k];}<br />
double slope(int a,int b){return double(y(a) - y(b)) / double(x(a) - x(b));}<br />
void calc(int k)<br />
{<br />
    getsiz(k,0);<br />
    s = siz[k];d[0] = INF;root = 0;<br />
    getroot(k,0);<br />
    k = root;<br />
    int topp = k;<br />
    while(fa[topp] != 0 && !vis[fa[topp]])topp = fa[topp];<br />
    vis[k] = true;<br />
    if(!vis[fa[k]] && fa[k] != 0)calc(fa[k]);<br />
    tot = 0;<br />
    for(int i = lin[k];i != 0;i = e[i].nxt)<br />
    {<br />
        if(vis[e[i].to])continue;<br />
        get(e[i].to,k);<br />
    }<br />
    for(int i = fa[k];i != fa[topp];i = fa[i])<br />
    {<br />
        if(dep[k] - dep[i] &gt; g[k])break;<br />
        f[k] = min(f[k],f[i] + p[k] * dep[k] - p[k] * dep[i] + q[k]);<br />
    }<br />
    sort(t + 1,t + 1 + tot,cmp_top);<br />
    htop = 0;<br />
    for(int j = 1,i = k;j &lt;= tot;++j)<br />
    {<br />
        while(i != fa[topp] && dep[t[j].top] &lt;= dep[i])<br />
        {<br />
            while(htop &gt;= 2 && slope(i,hull[htop]) &gt;= slope(hull[htop],hull[htop - 1]))--htop;<br />
            hull[++htop] = i;<br />
            i = fa[i];<br />
        }<br />
        int pos = t[j].id;<br />
        int l = 1,r = htop,midl,midr;<br />
        ll resl,resr;<br />
        ll res = 0x3f3f3f3f3f3f3f3f;<br />
        while(l &lt;= r)<br />
        {<br />
            int len = (r - l + 3) / 3;<br />
            midl = l + len - 1;midr = r - len + 1;<br />
            resl = f[hull[midl]] + p[pos] * dep[pos] - p[pos] * dep[hull[midl]] + q[pos];<br />
            resr = f[hull[midr]] + p[pos] * dep[pos] - p[pos] * dep[hull[midr]] + q[pos];<br />
            res = min(res,min(resl,resr));<br />
            if(resl &lt; resr)r = midr - 1;<br />
            else l = midl + 1;<br />
        }<br />
        f[pos] = min(f[pos],res);<br />
    }<br />
    for(int i = lin[k];i != 0;i = e[i].nxt)<br />
    {<br />
        if(!vis[e[i].to])calc(e[i].to);<br />
    }<br />
    return;<br />
}<br />
int main()<br />
{<br />
    int x;<br />
    scanf("%d%d",&n,&x);<br />
    int dad,len;<br />
    for(int i = 2;i &lt;= n;++i)<br />
    {<br />
        scanf("%d%d%lld%lld%lld",&dad,&len,&p[i],&q[i],&g[i]);<br />
        add(dad,i,len);<br />
    }<br />
    memset(f,0x3f,sizeof(f));<br />
    f[1] = 0;<br />
    dfs(1,1);<br />
    calc(1);<br />
    for(int i = 2;i &lt;= n;++i)printf("%lld\n",f[i]);<br />
    return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Solution2：
</h2>
</div>
<div class = "MarkdownCommonContent">
考虑那个之前在
$dfs$
的栈上维护凸包的做法，我们可以利用二进制分组来模拟栈，即用一棵线段树来维护这个栈，然后每次在
$\log$
个区间的凸包上查询最优解，但是这要求我们的二进制分组支持撤销，正确的做法是线段树每一层不维护最后一个满了的节点，也就是说每次把上一个区间的凸包构造出来，这样复杂度就是对的了，证明的话可以参考算法导论动态表的收缩和扩张，注意线段树必须是二的整次幂。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Code2：
</h2>
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;vector&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 200010<br />
typedef long long ll;<br />
struct edge<br />
{<br />
	int to,nxt;<br />
	ll v;<br />
}e[MAXN];<br />
int edgenum = 0;<br />
int lin[MAXN] = {0};<br />
void add(int a,int b,ll c)<br />
{<br />
	e[++edgenum] = (edge){b,lin[a],c};lin[a] = edgenum;<br />
	return;<br />
}<br />
ll p[MAXN],q[MAXN],d[MAXN];<br />
ll dep[MAXN];<br />
int N;<br />
struct node<br />
{<br />
	int lc,rc;<br />
	vector&lt;int&gt; v;<br />
}t[MAXN &lt;&lt; 2];<br />
int ptr = 0;<br />
int newnode(){return ++ptr;}<br />
int root;<br />
#define mid ((l + r) &gt;&gt; 1)<br />
int pre[MAXN &lt;&lt; 2],last[MAXN];<br />
void build(int &rt,int l,int r)<br />
{<br />
	rt = newnode();<br />
	pre[rt] = last[r - l + 1];last[r - l + 1] = rt;<br />
	if(l == r)return;<br />
	build(t[rt].lc,l,mid);<br />
	build(t[rt].rc,mid + 1,r);<br />
	return;<br />
}<br />
int tmp[MAXN],hull[MAXN],htop;<br />
bool cmp_x(int a,int b){return dep[a] &lt; dep[b];}<br />
ll f[MAXN];<br />
double slope(int a,int b){return double(f[a] - f[b]) / double(dep[a] - dep[b]);}<br />
bool maintained[MAXN &lt;&lt; 2];<br />
void merge(int rt,int l,int r)<br />
{<br />
	if(rt == 0)return;<br />
	if(l == r)return;<br />
	maintained[rt] = true;<br />
	t[rt].v.clear();<br />
	int lc = t[rt].lc,rc = t[rt].rc;<br />
	tmp[0] = 0;<br />
	for(vector&lt;int&gt;::iterator it = t[lc].v.begin();it != t[lc].v.end();++it)tmp[++tmp[0]] = *it;<br />
	for(vector&lt;int&gt;::iterator it = t[rc].v.begin();it != t[rc].v.end();++it)tmp[++tmp[0]] = *it;<br />
	sort(tmp + 1,tmp + 1 + tmp[0],cmp_x);<br />
	htop = 0;<br />
	for(int i = 1;i &lt;= tmp[0];++i)<br />
	{<br />
		while(htop &gt;= 2 && slope(tmp[i],hull[htop]) &lt;= slope(hull[htop],hull[htop - 1]))--htop;<br />
		hull[++htop] = tmp[i];<br />
	}<br />
	for(int i = 1;i &lt;= htop;++i)t[rt].v.push_back(hull[i]);<br />
	return;<br />
}<br />
void insert(int rt,int p,int k,int l,int r)<br />
{<br />
	if(l == r)<br />
	{<br />
		maintained[rt] = true;<br />
		t[rt].v.push_back(k);<br />
		return;<br />
	}<br />
	if(p &lt;= mid)insert(t[rt].lc,p,k,l,mid);<br />
	else insert(t[rt].rc,p,k,mid + 1,r);<br />
	if(p == r)merge(pre[rt],l - (r - l + 1),l - 1);<br />
	return;<br />
}<br />
void remove(int rt,int p,int l,int r)<br />
{<br />
	t[rt].v.clear();<br />
	maintained[rt] = false;<br />
	if(l == r)return;<br />
	if(p &lt;= mid)remove(t[rt].lc,p,l,mid);<br />
	else remove(t[rt].rc,p,mid + 1,r);<br />
	return;<br />
}<br />
#define INFLL 0x3f3f3f3f3f3f3f3f<br />
ll calc(vector&lt;int&gt; v,int k)<br />
{<br />
	int l = 0,r = v.size() - 1,midl,midr;<br />
	ll resl,resr,res = INFLL;<br />
	while(l &lt;= r)<br />
	{//cout &lt;&lt; "$$$ " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl;<br />
		int len = (r - l + 3) / 3;<br />
		midl = l + len - 1;midr = r - len + 1;<br />
		resl = f[v[midl]] + p[k] * (dep[k] - dep[v[midl]]) + q[k];<br />
		resr = f[v[midr]] + p[k] * (dep[k] - dep[v[midr]]) + q[k];<br />
		res = min(res,min(resl,resr));<br />
		if(resl &lt; resr)r = midr - 1;<br />
		else l = midl + 1;<br />
	}//cout &lt;&lt; "###" &lt;&lt; endl;<br />
	return res;<br />
}<br />
ll query(int rt,int L,int R,int k,int l,int r)<br />
{<br />
	if(L &lt;= l && r &lt;= R)<br />
	{//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl;<br />
		if(maintained[rt])return calc(t[rt].v,k);<br />
		else return min(calc(t[t[rt].lc].v,k),query(t[rt].rc,L,R,k,mid + 1,r));<br />
	}<br />
	long long res = INFLL;<br />
	if(L &lt;= mid)res = min(res,query(t[rt].lc,L,R,k,l,mid));<br />
	if(R &gt; mid)res = min(res,query(t[rt].rc,L,R,k,mid + 1,r));<br />
	return res;<br />
}<br />
int stack[MAXN],top = 0;<br />
void dfs(int k)<br />
{<br />
	stack[++top] = k;<br />
	int l = 1,r = top,md;<br />
	while(l &lt; r)<br />
	{<br />
		md = ((l + r) &gt;&gt; 1);<br />
		if(dep[k] - dep[stack[md]] &lt;= d[k])r = md;<br />
		else l = md + 1;<br />
	}<br />
	insert(root,top,k,1,N);//cout &lt;&lt; "st" &lt;&lt; endl;<br />
	f[k] = query(root,l,top,k,1,N);//cout &lt;&lt; "ed" &lt;&lt; endl;<br />
	for(int i = lin[k];i != 0;i = e[i].nxt)<br />
	{<br />
		dep[e[i].to] = dep[k] + e[i].v;<br />
		dfs(e[i].to);<br />
	}<br />
	remove(root,top,1,N);<br />
	--top;<br />
	return;<br />
}<br />
int main()<br />
{<br />
	int x;<br />
	scanf("%d%d",&n,&x);<br />
	N = 1;<br />
	while(N &lt; n)N = N &lt;&lt; 1;<br />
	build(root,1,N);<br />
	int fa;ll len;<br />
	for(int i = 2;i &lt;= n;++i)<br />
	{<br />
		scanf("%d%lld%lld%lld%lld",&fa,&len,&p[i],&q[i],&d[i]);<br />
		add(fa,i,len);<br />
	}<br />
	memset(f,0x3f,sizeof(f));f[1] = 0;<br />
	dfs(1);<br />
	for(int i = 2;i &lt;= n;++i)printf("%lld\n",f[i]);<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Solution3：
</h2>
</div>
<div class = "MarkdownCommonContent">
考虑利用树剖转移，也就是说先把树进行树链剖分，线段树维护凸壳，因为询问的区间是他到根的一条链，所以只有在这个区间都插入之后合并子节点的凸包，这样就只有插入了，然后
$dfs$
做就没了，时间复杂度
$O(n\log^3 n)$
。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Code3：
</h2>
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
<br />
</pre></code>
</div>
        </div>
        <div class="blogfile_showtag">
          <img src="http://pic.yupoo.com/wjh15101051/2380cc18/89ee2c05.png">
          In tag:
<a href="../tags/树-点分治.html">树-点分治</a> <a href="../tags/数据结构-cdq分治.html">数据结构-cdq分治</a> <a href="../tags/DP-斜率优化DP.html">DP-斜率优化DP</a> <a href="../tags/数据结构-二进制分组.html">数据结构-二进制分组</a> 
          <!--<a href="../tags/blog.html">blog</a>-->
        </div>
      </div>
    </div>
    <div id="middle_nav">
      <div class="blog_host">
        <div class="nav_avator">
          <img src="http://pic.yupoo.com/wjh15101051/72c1aeab/f51d56e0.jpg" alt="avator">
        </div>
        <div class="nav_ID">
          wjh15101051
        </div>
      </div>
      <div class="nav_list">
        <li class="tags">
          <a href="../tags.html">
            <img src="http://pic.yupoo.com/wjh15101051/2380cc18/89ee2c05.png" class="list_icon" id="tags_image">
            Tags
          </a>
        </li>
        <li class="categories">
          <a href="../categories.html">
            <img src="http://pic.yupoo.com/wjh15101051/2ea96b56/7882c4ab.png" class="list_icon" id="categories_image">
            Categories
          </a>
        </li>
        <li class="timeline">
          <a href="../timeline.html">
            <img src="http://pic.yupoo.com/wjh15101051/30365cc7/c1a3be15.png" class="list_icon" id="timeline_image">
            Timeline
          </a>
        </li>
        <li class="about">
          <a href="../about.html">
            <img src="http://pic.yupoo.com/wjh15101051/24f1cb41/e239086e.png" class="list_icon" id="about_image">
            About
          </a>
        </li>
        <li class="toolbox">
          <a href="../toolbox.html">
            <img src="http://pic.yupoo.com/wjh15101051/dee9f673/d3cf682a.png" class="list_icon" id="toolbox_image">
            Toolbox
          </a>
        </li>
        <li class="friends">
            <div class="friends_text">
              <img src="http://pic.yupoo.com/wjh15101051/d291ebed/29f9c807.png" id="friends_image">
              Friends
            </div>
            <div id="fp_friends_list">
              <div id="SGcolin">
                <a href="http://blog.gyx.me/" target="_blank">SGcolin</a>
              </div>
              <div id="Xingcy">
                <a href="https://www.cnblogs.com/xcysblog/" target="_blank">Xingcy</a>
              </div>
              <div id="ZH_comld">
                <a href="https://www.cnblogs.com/ZH-comld/" target="_blank">ZH_comld</a>
              </div>
            </div>
            <br>
          </div>
        </li>
      </div>
    <div class="music_player">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
      <script src="https://blog-static.cnblogs.com/files/yjlaugus/APlayer.min.js"></script>
      <div id="aplayer" class="aplayer"  data-id="5313691453" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
      <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
    </div>
    <div class="bottom">
      <div>
        Copyright © 2020
        <a id="copyright_user_a" href="index.html">
          <span id="copyright_user">wjh15101051</span>
        </a>
      </div>
      <div class="bottom_anime">ღゝ◡╹)ノ♡</div>
    </div>
  </div>
</body>
</html>
