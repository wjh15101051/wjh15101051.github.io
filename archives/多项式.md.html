<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>多项式相关</title>
  <link rel="stylesheet" type="text/css" id="frame_style" href="../css/frame_style1.css">
  <link rel="stylesheet" type="text/css" id="Markdown_style" href="../css/Markdown_style.css">
  <script type="text/javascript" src="../jscode/frame.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="stylesheet" href="https://ziyuan.fenxianglu.cn/js/highlight/styles/default.css">
  <script src="https://ziyuan.fenxianglu.cn/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
</head>
<body>
  <div class="main">
    <div class="head">
      <div class="title1">
        <a href="../index.html">wjh15101051's space</a>
      </div>
      <div class="title2">
        卧薪尝胆，厚积薄发。
      </div>
    </div>
    <div id="middle_blogfile">
      <div class="blog_blogfile">
        <div class="blogfile_title">
            多项式相关
        </div>
        <div class="blogfile_stitle">
          <img src="http://pic.yupoo.com/wjh15101051/1e0e1b3a/118165c5.jpg">
          Date: Thu Jun 14 21:07:01 CST 2018
          <img src="http://pic.yupoo.com/wjh15101051/2ea96b56/7882c4ab.png">
          In Category:
          <a href="../categories/总结.html">总结</a>
        </div>
        <div class="blogfile_content">
<div class = "MarkdownCommonContent">
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
卷积
</h2>
</div>
<div class = "MarkdownCommonContent">
$$
f[k]=\sum_{i\oplus j=k} a[i]\times b[j]
$$
</div>
<div class = "MarkdownCommonContent">
系数表达式
$\to$
频域
</div>
<div class = "MarkdownCommonContent">
点值表达式
$\to$
时域
</div>
<div class = "MarkdownCommonContent">
时域卷积，频域乘积，频域卷积，时域乘积。
</div>
<div class = "MarkdownCommonContent">
$O(Nlog N)$
计算卷积。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
快速傅里叶变换
</h2>
</div>
<div class = "MarkdownCommonContent">
用主
$n$
次复数单位根
$\omega_n^k$
插值。
</div>
<div class = "MarkdownCommonContent">
$$
\omega_n^k=(e^{\frac{2\pi i}{n}})^k=\cos k\frac{2\pi}{n}+i \sin k\frac{2\pi}{n}
$$
消去引理：
</div>
<div class = "MarkdownCommonContent">
$$
\omega_{dn}^{dk}=(e^{\frac{2\pi i}{dn}})^{dk}=(e^{\frac{2\pi i}{n}})^k=\omega_n^k
$$
折半引理：
</div>
<div class = "MarkdownCommonContent">
$$
\omega_n^{k+\frac{n}{2}}=(\cos(\frac{n}{2}\times \frac{2\pi}{n})+i\sin(\frac n 2\times \frac{2\pi} 2))\times \omega_n^k=(\cos\pi+i\sin\text{ }\pi)\times \omega_n^k=-\omega_n^k
$$
求和引理：
</div>
<div class = "MarkdownCommonContent">
$$
\sum_{i=0}^{n-1}(\omega_n^k)^i=0(k\ne0)
$$
对系数奇偶分类
</div>
<div class = "MarkdownCommonContent">
$$
\begin{align}
&A(x)=(a_0+a_2x^2+a_4x^4+⋯+a_{n−2}x^{n−2})+(a_1x+a_3x^3+a_5x^5+⋯+a_{n−1}x^{n−1})\\
&A_1(x)=a_0+a_2x+a_4x^2+⋯+a_{n−2}x^{\frac n 2−1}\\
&A_2(x)=a_1+a_3x+a_5x^2+⋯+a_{n−1}x^{\frac n 2−1}
\end{align}
$$
$k&lt;\frac n 2$
</div>
<div class = "MarkdownCommonContent">
$$
A(\omega_n^k)=A_1((\omega_n^k)^2)+\omega_n^kA_2((\omega_n^k)^2)=A_1(\omega_\frac n 2 ^k)+\omega_n^kA_2(\omega_\frac n 2 ^k)
$$
$k&gt;\frac n 2$
</div>
<div class = "MarkdownCommonContent">
$$
\begin{align}
&A(\omega_n^{k+\frac n 2})\\
=&A_1((\omega_n^{k+\frac n 2})^2)+\omega_n^{k+\frac n 2}A_2((\omega_n^{k+\frac n 2})^2)\\
=&A_1(\omega_n^{2k}\times\omega_n^k)-\omega_n^kA_2(\omega_n^{2k}\times\omega_n^n)\\
=&A_1(\omega_n^{2k})-\omega_n^kA_2(\omega_n^{2k})\\
=&A_1(\omega_\frac n 2^k)-\omega_n^kA_2(\omega_\frac n 2^k)
\end{align}
$$
在外层循环
$i$
，
$F[p]$
表示分成的段中
$\omega_i^k$
在当前这个点插值的值，刚开始是多项式系数，即为
$\omega_1^1$
在各个点插值的值，最后就是点值表达式，即为
$\omega_n^p$
在各个点插值的值。
</div>
<div class = "MarkdownCommonContent">
逆
$FFT$
：
</div>
<div class = "MarkdownCommonContent">
已知
$\omega_n^k$
插值得到的点值表达式
$B$
，求系数表达式
$A$
使得
$A(\omega_n^k)=B_k$
。
</div>
<div class = "MarkdownCommonContent">
用
$-\omega_n^k$
插值：
</div>
<div class = "MarkdownCommonContent">
$$
C_k=\sum_{i=0}^{n-1}B_k(\omega_n^{-k})^i=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}A_j(\omega_n^i)^j)(\omega_n^{-k})^i=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}A_j(\omega_n^{j-k})^i=\sum_{j=0}^{n-1}A_j\sum_{i=0}^{n-1}(\omega_n^{j-k})^i
$$
由求和引理得：当
$k\ne 0$
时：
$$
\sum_{i=0}^{n-1}(\omega_n^k)^i=0
$$
否则：
$$
\begin{align}\sum_{i=0}^{n-1}(\omega_n^k)^i=n\end{align}
$$
所以
$C_k=n\times A_k$
，即
$A_k=C_k/n$
。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
const double PI = acos(-1);<br />
int n,m;<br />
#define MAXN 3100013<br />
int rev[MAXN];<br />
struct complex<br />
{<br />
	double r,i;<br />
	complex(double r_ = 0.0,double i_ = 0.0){r = r_;i = i_;}<br />
}a[MAXN],b[MAXN];<br />
complex operator + (complex a,complex b){return complex(a.r + b.r,a.i + b.i);}<br />
complex operator - (complex a,complex b){return complex(a.r - b.r,a.i - b.i);}<br />
complex operator * (complex a,complex b){return complex(a.r * b.r - a.i * b.i,a.r * b.i + a.i * b.r);}<br />
void FFT(complex *f,int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
    {<br />
        if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
    }<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		complex wn(cos(-type * 2 * PI / i),sin(-type * 2 * PI / i));<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			complex w(1,0);<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				complex u = f[k],t = w * f[k + i / 2];<br />
				f[k] = u + t;<br />
				f[k + i / 2] = u - t;<br />
				w = w * wn;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		for(int i = 0;i &lt; l;++i)<br />
		{<br />
			f[i].r /= l;<br />
		}<br />
	}<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d%d",&n,&m);<br />
	for(int i = 0;i &lt;= n;++i)scanf("%lf",&a[i].r);<br />
	for(int i = 0;i &lt;= m;++i)scanf("%lf",&b[i].r);<br />
	int len,l;<br />
	for(len = 1,l = 0;len &lt;= n + m;len = len &lt;&lt; 1,++l);<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	FFT(a,len,1);<br />
	FFT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		a[i] = a[i] * b[i];<br />
	}<br />
	FFT(a,len,-1);<br />
	for(int i = 0;i &lt;= n + m;++i)<br />
	{<br />
		printf("%d ",(int)(a[i].r + 0.5));<br />
	}<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
快速数论变换
</h2>
</div>
<div class = "MarkdownCommonContent">
计算卷积对
$P=r\times2^k+1$
取模的值。
</div>
<div class = "MarkdownCommonContent">
原根的幂在
$mod\text{ }p$
意义下有循环性质。
</div>
<div class = "MarkdownCommonContent">
将
$g^{\frac{P-1}{n}}$
看作
$e^{-\frac{2\pi i}{n}}$
的等价
</div>
<div class = "MarkdownCommonContent">
设
$\omega_n^k=(g^{\frac{P-1}{n}})^k$
</div>
<div class = "MarkdownCommonContent">
消去引理：
</div>
<div class = "MarkdownCommonContent">
$\omega_{dn}^{dk}=(g^{\frac{P-1}{dn}})^{dk}=(g^{\frac{P-1}{n}})^k=\omega_n^k$
</div>
<div class = "MarkdownCommonContent">
折半引理：
</div>
<div class = "MarkdownCommonContent">
$\omega_n^{k+\frac{n}{2}}=(g^{\frac{P-1}{n}})^{k+\frac n 2}=(g^{\frac{P-1}{n}})^k\times g^{\frac{P-1}{2}}$
</div>
<div class = "MarkdownCommonContent">
由于
$g^{\frac{P-1} 2}\equiv-1(mod\text{ }P)$
</div>
<div class = "MarkdownCommonContent">
$\omega_n^{k+\frac n 2}=-g^{\frac{P-1} 2}=-\omega_n^k$
</div>
<div class = "MarkdownCommonContent">
求和引理：
</div>
<div class = "MarkdownCommonContent">
$\begin{align}\sum_{i=0}^{n-1}(\omega_n^k)^i=\frac{(\omega_n^k)^n-1}{\omega_n^k-1} =\frac{((g^\frac {P-1}{n})^k)^n-1}{(g^{\frac{P-1}{n}})^k-1}=\frac{(g^{P-1})^k-1}{\omega_n^k-1}\end{align}$
</div>
<div class = "MarkdownCommonContent">
由费马小定理得：
$g^{P-1}\equiv1(mod\text{ }P)$
</div>
<div class = "MarkdownCommonContent">
$\begin{align}= \frac{1-1}{\omega_n^k-1}=0\end{align}$
</div>
<div class = "MarkdownCommonContent">
即
$\begin{align}\sum_{i=0}^{n-1}(\omega_n^k)^i=0\end{align}$
</div>
<div class = "MarkdownCommonContent">
于是就和
$FFT$
一样了。
</div>
<div class = "MarkdownCommonContent">
逆
$NTT$
时也应除掉
$n$
，计算一下
$n$
对
$MOD$
的逆元，即
$n^{MOD-2}$
。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
typedef long long ll;<br />
const ll P = 998244353;<br />
int n,m;<br />
#define MAXN 4000010<br />
ll a[MAXN],b[MAXN];<br />
int rev[MAXN];<br />
ll ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
ll power(ll a,ll b)<br />
{<br />
	ll res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = (res * a) % P;<br />
		a = (a * a) % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void NTT(ll *f,int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		ll wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			ll w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = (w * f[k + i / 2]) % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = (w * wn) % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		ll ni = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)<br />
		{<br />
			f[i] = (f[i] * ni) % P;<br />
		}<br />
	}<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d%d",&n,&m);<br />
	for(int i = 0;i &lt;= n;++i)scanf("%lld",&a[i]);<br />
	for(int i = 0;i &lt;= m;++i)scanf("%lld",&b[i]);<br />
	int len,l;<br />
	for(len = 1,l = 0;len &lt;= n + m;len = len &lt;&lt; 1,++l);<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
	NTT(a,len,1);<br />
	NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		a[i] = a[i] * b[i] % P;<br />
	}<br />
	NTT(a,len,-1);<br />
	for(int i = 0;i &lt;= n + m;++i)printf("%lld ",a[i]);<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式求逆
</h2>
</div>
<div class = "MarkdownCommonContent">
给出
$n-1$
次多项式
$F(x)$
，求一个
$n-1$
次多项式
$G(x)$
使得
$F(x)\times G(x)\equiv 1(mod\ x^n)$
</div>
<div class = "MarkdownCommonContent">
若
$n=1$
，则
$\%x=1$
，那么要求的就是
$F[0]$
的逆元，即
$F[0]^{P-2}$
</div>
<div class = "MarkdownCommonContent">
若
$n&gt;1$
，使用倍增方法。
</div>
<div class = "MarkdownCommonContent">
假设已经求出了
$F(x)G'(x)\equiv1\ (mod\ x^{\lceil \frac n 2\rceil})$
</div>
<div class = "MarkdownCommonContent">
由于
$F(x)G(x)\equiv1(mod\ x^n)$
，则
$F(x)G(x)\equiv 1\ (mod\ x^{\lceil \frac n 2 \rceil})$
</div>
<div class = "MarkdownCommonContent">
两式相减得：
$F(x)(G'(x)-G(x))\equiv 0\ (mod\ x^{\lceil \frac n 2 \rceil})$
</div>
<div class = "MarkdownCommonContent">
由于
$F(x)$
不为
$0$
，则
$G'(x)-G(x)\equiv 0\ (mod\ x^{\lceil\frac n 2\rceil})$
</div>
<div class = "MarkdownCommonContent">
平方，得：
$G'(x)^2+G(x)^2-2G'(x)G(x)\equiv0\ (mod\ x^n)$
</div>
<div class = "MarkdownCommonContent">
为什么模
$x^n$
呢？因为根据卷积的定义，有
</div>
<div class = "MarkdownCommonContent">
$\begin{align}(G'(x)-G(x))^2[i]=\sum_{j=0}^i((G'(x)-G(x))[i]\times(G'(x)-G(x))[j-i])\end{align}$
</div>
<div class = "MarkdownCommonContent">
由于
$i$
和
$j-i$
至少有一项小于
$\lceil\frac n 2\rceil$
，而
$(x^{\lceil\frac n 2\rceil})^2 \ge x^n$
，所以乘完之后为零。
</div>
<div class = "MarkdownCommonContent">
由于
$F(x)G(x)\equiv1\ (mod\ x^n)$
，所以乘上一个
$F(x)$
得：
$F(x)G'(x)^2+G(x)-2G'(x)\equiv0\ (mod\ x^n)$
</div>
<div class = "MarkdownCommonContent">
于是
$G(x)\equiv2G'(x)-F(x)G'(x)^2\ (mod\ x^n)$
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 200010<br />
typedef long long ll;<br />
const ll P = 998244353;<br />
ll w[MAXN &lt;&lt; 2],*g = w + (MAXN &lt;&lt; 1);<br />
ll A[MAXN &lt;&lt; 1],B[MAXN &lt;&lt; 1],c[MAXN &lt;&lt; 1];<br />
int rev[MAXN &lt;&lt; 1];<br />
ll power(ll a,ll b)<br />
{<br />
	ll res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a % P;<br />
		a = a * a % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void NTT(ll f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
		if(i &lt; rev[i])<br />
			swap(f[i],f[rev[i]]);<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		ll wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			ll w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		ll ni = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)<br />
			f[i] = f[i] * ni % P;<br />
	}<br />
	return;<br />
}<br />
void work(int deg,ll *a,ll *b)<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2);<br />
		return;<br />
	}<br />
	work(((deg + 1) &gt;&gt; 1),a,b);<br />
	int len,l;<br />
	for(len = 1,l = 0;len &lt; (deg &lt;&lt; 1);len = len &lt;&lt; 1,++l);<br />
	for(int i = 1;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; deg;++i)c[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)c[i] = 0;<br />
	NTT(b,len,1);NTT(c,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = ((2 * b[i] % P) - (c[i] * b[i] % P * b[i] % P) + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 0;i &lt; n;++i)scanf("%lld",&A[i]);<br />
	work(n,A,B);<br />
	for(int i = 0;i &lt; n;++i)printf("%lld ",B[i]);<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
分治FFT
</h2>
</div>
<div class = "MarkdownCommonContent">
大概要求的就是给定长度为
$n-1$
的数组
$g[1],g[2],\dots,g[n-1]$
，求
$f[0],f[1],\dots,f[n-1]$
，其中
$$
f[i]=\sum_{j=1}^if[i-j]g[j]
$$
边界为
$f[0]=1$
。答案模
$998244353$
。（洛谷分治FFT模板）
</div>
<div class = "MarkdownCommonContent">
首先可以类似
$cdq$
分治那样的做法，左边的位置对右边的贡献是独立的，假如求出了
$[l,mid]$
的答案，对右边
$x$
位置的贡献为：
$$
w_x=\sum_{i=l}^{mid}f[i]\times g[x-i]
$$
这本质上是个卷积，可以用
$FFT$
加速，时间复杂度
$O(n\log^2n )$
。
</div>
<div class = "MarkdownCommonContent">
但是还有更优秀的做法。
</div>
<div class = "MarkdownCommonContent">
考虑多项式
$F$
，把它写成形式幂级数或者说是生成函数的形式，即：
$$
F(x)=\sum_{i=0}^\infty f[i]x^i
$$
由于
$g_0=0$
，所以有
$F(x)G(x)=F(x)-f_0$
，这个也很好理解，因为卷积的过程就是上面那个式子求的过程，所以自然
$F$
除了最后一位别的都是不变的。
</div>
<div class = "MarkdownCommonContent">
那么就有
$F(x)\equiv(1-G(x))^{-1}(\mod x^n)$
，于是用多项式求逆解决就好了。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 400010<br />
#define P 998244353<br />
typedef long long ll;<br />
ll F[MAXN],G[MAXN];<br />
ll ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
int rev[MAXN];<br />
ll power(ll a,ll b)<br />
{<br />
	ll res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a % P;<br />
		a = a * a % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void NTT(ll f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		ll wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			ll w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		for(int i = 0;i &lt; l;++i)f[i] = f[i] * power(l,P - 2) % P;<br />
	}<br />
	return;<br />
}<br />
ll c[MAXN];<br />
void calc_inv(int deg,ll a[],ll b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2) % P;<br />
		return;<br />
	}<br />
	calc_inv((deg + 1) &gt;&gt; 1,a,b);<br />
	int l = 0,len = 1;<br />
	for(;len &lt; (deg &lt;&lt; 1);len = len &lt;&lt; 1,++l);<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; deg;++i)c[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)c[i] = 0;<br />
	NTT(c,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = (2 * b[i] % P - c[i] % P * b[i] % P * b[i] % P + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 1;i &lt; n;++i)scanf("%lld",&G[i]);<br />
	for(int i = 1;i &lt; n;++i)G[i] = P - G[i];<br />
	G[0] = (G[0] + 1) % P;<br />
	int len;<br />
	for(len = 1;len &lt; n;len = len &lt;&lt; 1);<br />
	calc_inv(len,G,F);<br />
	for(int i = 0;i &lt; n;++i)printf("%lld ",F[i]);<br />
	cout &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
另一种做法是
$CDQ$
分治，也就是考虑左边对右边的影响，用
$FFT$
加速，注意下标的变化。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 400010<br />
typedef long long ll;<br />
ll g[MAXN];<br />
ll f[MAXN];<br />
#define P 998244353<br />
ll power(ll a,ll b)<br />
{<br />
    ll res = 1;<br />
    while(b &gt; 0)<br />
    {<br />
        if(b & 1)res = res * a % P;<br />
        a = a * a % P;<br />
        b = b &gt;&gt; 1;<br />
    }<br />
    return res;<br />
}<br />
namespace poly<br />
{<br />
    int rev[MAXN];<br />
    ll ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
    void NTT(ll f[],int l,int type)<br />
    {<br />
        for(int i = 0;i &lt; l;++i)<br />
        {<br />
            if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
        }<br />
        for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
        {<br />
            ll wn = g[type * l / i];<br />
            for(int j = 0;j &lt; l;j += i)<br />
            {<br />
                ll w = 1;<br />
                for(int k = j;k &lt; j + i / 2;++k)<br />
                {<br />
                    ll u = f[k],t = w * f[k + i / 2] % P;<br />
                    f[k] = (u + t) % P;<br />
                    f[k + i / 2] = (u - t + P) % P;<br />
                    w = w * wn % P;<br />
                }<br />
            }<br />
        }<br />
        if(type == -1)<br />
        {<br />
            ll ni = power(l,P - 2);<br />
            for(int i = 0;i &lt; l;++i)f[i] = f[i] * ni % P;<br />
        }<br />
        return;<br />
    }<br />
    void mul(ll a[],ll b[],ll res[],int deg)<br />
    {<br />
        int l = 0,len = 1;<br />
        for(;len &lt;= (deg &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
        g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
        for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
        for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
        NTT(a,len,1);NTT(b,len,1);<br />
        for(int i = 0;i &lt; len;++i)res[i] = a[i] * b[i] % P;<br />
        NTT(res,len,-1);<br />
        for(int i = 0;i &lt; len;++i)a[i] = b[i] = 0;<br />
        return;<br />
    }<br />
}<br />
ll tmp1[MAXN],tmp2[MAXN],tmp3[MAXN];<br />
void cdq(int l,int r)<br />
{<br />
    if(l == r)return;<br />
    int mid = ((l + r) &gt;&gt; 1);<br />
    cdq(l,mid);<br />
    for(int i = l;i &lt;= mid;++i)tmp1[i - l] = f[i];<br />
    for(int i = 0;i &lt;= r - l + 1;++i)tmp2[i] = g[i];<br />
    int d = r - l + 1 + 1;<br />
    poly::mul(tmp1,tmp2,tmp3,d);<br />
    for(int i = mid + 1;i &lt;= r;++i)f[i] = (f[i] + tmp3[i - l]) % P;<br />
    for(int i = 0;i &lt; d;++i)tmp1[i] = tmp2[i] = tmp3[i] = 0;<br />
    cdq(mid + 1,r);<br />
    return;<br />
}<br />
int main()<br />
{<br />
    scanf("%d",&n);<br />
    for(int i = 1;i &lt; n;++i)scanf("%lld",&g[i]);<br />
    f[0] = 1;<br />
    cdq(0,n);<br />
    for(int i = 0;i &lt; n;++i)printf("%lld ",f[i]);<br />
    cout &lt;&lt; endl;<br />
    return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式除法
</h2>
</div>
<div class = "MarkdownCommonContent">
给定一个
$n$
次多项式
$F(x)$
和一个
$m$
次多项式
$G(x)$
，请求出多项式
$Q(x)$
，
$R(x)$
，满足以下条件：
</div>
<div class = "MarkdownCommonContent">
$Q(x)$
次数为
$n-m$
，
$R(x)$
次数小于
$m$
，
$F(x) = Q(x) \times G(x) + R(x)$
 
</div>
<div class = "MarkdownCommonContent">
所有的运算在模
$998244353$
意义下进行。
</div>
<div class = "MarkdownCommonContent">
首先定义多项式的反转，设一个次数界为
$n$
的多项式
$F(x)$
，
$F^R(x)=x^nF(\frac 1 x)$
，因为观察一下就会发现这个实际上是把原多项式高低次数的位置依次交换。
</div>
<div class = "MarkdownCommonContent">
那么我们可以进行这样一个操作，把上面那个式子两边同成
$x^n$
，并把
$\frac 1 x$
当作
$x$
带入，即：
$$
\begin{align}
&x^nF(\frac 1 x)=x^{n-m}Q(\frac 1 x)\times x^mG(\frac 1 x)+x^{n-m+1}x^{m-1}R(\frac 1 x)\\
\Longrightarrow&F^R(x)=Q^R(x)\times G^R(x)+x^{n-m+1}R^R(x)
\end{align}
$$
由于我们最终要求的
$Q(x)$
是一个
$n-m$
次多项式，所以有：
$$
F^R(x)=Q^R(x)\times G^R(x)(\mod x^{n-m+1})
$$
所以
$Q^R=F^R(x)\times (G^R)^{-1}(\mod x^{n-m+1})$
，多项式求逆就可以了。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式取模
</h2>
</div>
<div class = "MarkdownCommonContent">
多项式除法后把
$Q$
带回去解出
$R$
即可。
</div>
<div class = "MarkdownCommonContent">
除了优化递推好像没啥用。
</div>
<div class = "MarkdownCommonContent">
多项式除法和取模的代码：
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n,m;<br />
#define MAXN 300010<br />
typedef long long ll;<br />
const ll P = 998244353;<br />
ll ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
int rev[MAXN];<br />
ll F[MAXN],G[MAXN],Q[MAXN];<br />
ll power(ll a,ll b)<br />
{<br />
	ll res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a % P;<br />
		a = a * a % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void NTT(ll f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		ll wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			ll w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		ll inv = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)f[i] = f[i] * inv % P;<br />
	}<br />
	return;<br />
}<br />
ll c[MAXN];<br />
void calc_inv(int deg,ll a[],ll b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2);<br />
		return;<br />
	}<br />
	calc_inv((deg + 1) &gt;&gt; 1,a,b);<br />
	int l = 0,len = 1;<br />
	for(;len &lt; (deg &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; deg;++i)c[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)c[i] = 0;<br />
	NTT(c,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = (2 * b[i] % P - c[i] * b[i] % P * b[i] % P + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d%d",&n,&m);<br />
	for(int i = 0;i &lt;= n;++i)scanf("%lld",&F[n - i]);<br />
	for(int i = 0;i &lt;= m;++i)scanf("%lld",&G[m - i]);<br />
	calc_inv(n - m + 1,G,Q);<br />
	++n;++m;<br />
	int l = 0,len = 1;<br />
	for(;len &lt; (n &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
	NTT(F,len,1);NTT(Q,len,1);<br />
	for(int i = 0;i &lt; len;++i)Q[i] = Q[i] * F[i] % P;<br />
	NTT(Q,len,-1);NTT(F,len,-1);<br />
	for(int i = n - m + 1;i &lt; len;++i)Q[i] = 0;<br />
	for(int i = 0,j = n - m;i &lt; j;++i,--j)swap(Q[i],Q[j]);<br />
	for(int i = 0;i &lt; n - m + 1;++i)printf("%lld ",Q[i]);puts("");<br />
	for(int i = 0,j = n - 1;i &lt; j;++i,--j)swap(F[i],F[j]);<br />
	for(int i = 0,j = m - 1;i &lt; j;++i,--j)swap(G[i],G[j]);<br />
	l = 0,len = 1;<br />
	for(;len &lt; n + 1;len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = g[i - 1] * g[1] % P;<br />
	NTT(G,len,1);NTT(Q,len,1);<br />
	for(int i = 0;i &lt; len;++i)Q[i] = Q[i] * G[i] % P;<br />
	NTT(Q,len,-1);<br />
	for(int i = 0;i &lt; len;++i)F[i] = (F[i] - Q[i] + P) % P;<br />
	for(int i = 0;i &lt; m - 1;++i)printf("%d ",F[i]);puts("");<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
##多项式牛顿迭代法
</div>
<div class = "MarkdownCommonContent">
假设我们有一个多项式的函数
$G(x)$
，我们想求它的一个零点，换一种方法来说就是求解：
$$
G(F(x))=0(\mod x^n)
$$
首先当
$n=1$
时，
$G(F(x))=0(\mod x)$
，这个需要单独求出。
</div>
<div class = "MarkdownCommonContent">
当
$n\ne 1$
时，假设已经求出了：
$$
G(F_0(x))=0(\mod x^{\lfloor\frac n 2\rfloor})
$$
我们可以把
$G(x)$
在
$F_0(x)$
这里泰勒展开，即：
$$
G(F(x))=G(F_0(x))+\frac{G'(F_0(x))}{1!}(F(x)-F_0(x))+\frac{G''(F_0(x))}{2!}(F(x)-F_0(x))^2+\cdots
$$
由于
$F(x)$
和
$F_0(x)$
最后
$\lfloor\frac n 2\rfloor$
项一定相同，因为他们实际上只是模的东西不一样，本质是一个东西，所以
$(F(x)-F_0(x))^2$
后
$n$
项一定都是
$0$
，于是就可以模掉了，于是有：
$$
G(F(x))=G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))=0(\mod x^n)
$$
于是就有：
$$
F(x)=F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}
$$
所以如果支持把
$F_0(x)$
快速代入
$G()$
，那么我们就有了一个复杂度为
$T(n)=T(\frac n 2)+O(代入G+n\log n)$
的求解多项式函数
$G(x)$
的零点的做法。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式开方
</h2>
</div>
<div class = "MarkdownCommonContent">
给出多项式
$H(x)$
，要求一个多项式
$F(x)$
满足：
$$
F^2(x)=H(x)(\mod x^n)
$$
做法还是利用牛顿迭代，设函数
$G(x)$
为：
$$
G(F(x))=F^2(x)-H(x)
$$
带入牛顿迭代公式为：
$$
F=F_0-\frac{G(F_0)}{G'(F_0)}=F_0-\frac{F_0^2-H}{2F_0}
$$
时间复杂度
$O(n\log n)$
。
</div>
<div class = "MarkdownCommonContent">
注意当
$deg=0$
的时候要求模意义下的二次剩余，二次剩余有一个叫做
$Cipolla$
的算法，但是如果
$0$
次项的值已知那么就可以在下面把二次剩余枚举得出。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n,m;<br />
#define MAXN 400010<br />
int ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
int rev[MAXN];<br />
#define P 998244353<br />
int power(int a,int b)<br />
{<br />
	int res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = 1ll * res * a % P;<br />
		a = 1ll * a * a % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void NTT(int f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		int wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			int w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				int u = f[k],t = 1ll * w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = 1ll * w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		int ni = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)f[i] = 1ll * f[i] * ni % P;<br />
	}<br />
	return;<br />
}<br />
int invtmp[MAXN];<br />
void calc_inv(int deg,int a[],int b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2);<br />
		return;<br />
	}<br />
	calc_inv((deg + 1) &gt;&gt; 1,a,b);<br />
	int l = 0,len = 1;<br />
	for(;len &lt;= (deg &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; deg;++i)invtmp[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)invtmp[i] = 0;<br />
	NTT(invtmp,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = (2 * b[i] % P - 1ll * invtmp[i] * b[i] % P * b[i] % P + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	//for(int i = 0;i &lt; deg;++i)cout &lt;&lt; b[i] * 2 % P &lt;&lt; " ";cout &lt;&lt; endl;<br />
	return;<br />
}<br />
int multmp[MAXN];<br />
void mul(int deg,int a[],int b[])<br />
{<br />
	int l = 0,len = 1;<br />
	for(;len &lt;= (deg &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; len;++i)multmp[i] = b[i];<br />
	NTT(a,len,1);NTT(multmp,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		a[i] = 1ll * a[i] * multmp[i] % P;<br />
	}<br />
	NTT(a,len,-1);<br />
	for(int i = deg;i &lt; len;++i)a[i] = 0;<br />
	return;<br />
}<br />
#define REM 1<br />
int tmp1[MAXN],tmp2[MAXN];<br />
void calc_sqr(int deg,int a[],int b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = REM;<br />
		return;<br />
	}<br />
	calc_sqr((deg + 1) &gt;&gt; 1,a,b);<br />
	for(int i = 0;i &lt; deg;++i)tmp1[i] = b[i];<br />
	mul(deg,tmp1,b);<br />
	for(int i = 0;i &lt; deg;++i)tmp1[i] = (tmp1[i] - a[i] + P) % P;<br />
	memset(tmp2,0,sizeof(tmp2));<br />
	calc_inv(deg,b,tmp2);<br />
	for(int i = 0;i &lt; deg;++i)tmp2[i] = 1ll * tmp2[i] * power(2,P - 2) % P;<br />
	mul(deg,tmp1,tmp2);<br />
	for(int i = 0;i &lt; deg;++i)b[i] = (b[i] - tmp1[i] + P) % P;<br />
	for(int i = 0;i &lt; deg;++i)cout &lt;&lt; b[i] &lt;&lt; " ";cout &lt;&lt; endl;<br />
	return;<br />
}<br />
int H[MAXN],F[MAXN];<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 0;i &lt; n;++i)scanf("%d",&H[i]);<br />
	calc_sqr(n,H,F);<br />
	for(int i = 0;i &lt; n;++i)printf("%d ",F[i]);<br />
	cout &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式取模优化常系数齐次线性递推
</h2>
</div>
<div class = "MarkdownCommonContent">
常系数齐次线性递推，就是给你一个线性递推关系：
$$
f_n=\sum_{i=1}^ka_if_{n-i}
$$
让你求第
$n$
项的值。
</div>
<div class = "MarkdownCommonContent">
显然可以矩阵乘法，但是矩阵乘法复杂度是
$O(k^3\log n)$
，不难发现复杂度的瓶颈主要在
$k^3$
这部分，因为对于绝大多数问题，
$\log n$
都比较小。
</div>
<div class = "MarkdownCommonContent">
<h3 class = "MarkdownH3">
特征多项式：
</h3>
</div>
<div class = "MarkdownCommonContent">
<h4 class = "MarkdownH4">
特征值，特征向量：
</h4>
</div>
<div class = "MarkdownCommonContent">
如果有一个常数
$\lambda$
和一个向量
$\overrightarrow v$
，满足
$\lambda\overrightarrow v=A\overrightarrow v$
，则称
$\overrightarrow v$
为矩阵
$A$
的一组特征向量，
$\lambda$
为矩阵
$A$
的一组特征值。
</div>
<div class = "MarkdownCommonContent">
秩为
$k$
的矩阵有
$k$
组线性不相关的特征向量。
</div>
<div class = "MarkdownCommonContent">
<h4 class = "MarkdownH4">
特征多项式，特征方程：
</h4>
</div>
<div class = "MarkdownCommonContent">
对关系式进行变换：
$(\lambda I-A)\overrightarrow v=0$
，这个等式有解的充要条件是
$\det(\lambda I-A)=0$
，那么我们可以把
$\det(\lambda I-A)$
看作一个
$k$
次多项式，记为：
$f(\lambda)=\det(\lambda I-A)$
，这个称为矩阵的特征多项式，
$f(\lambda)$
称为矩阵的特征方程，这个方程有
$k$
个解可以写作：
$$
f(\lambda)=\prod_{i=1}^k(\lambda_i-\lambda)
$$
每个解是一个特征值。
</div>
<div class = "MarkdownCommonContent">
<h3 class = "MarkdownH3">
Cayley-Hamilton定理：
</h3>
</div>
<div class = "MarkdownCommonContent">
根据：Cayley-Hamilton定理，有
$f(A)=0$
，证明的话：
$$
\begin{align}
&f(A)=\prod_{i=1}^k(\lambda_iI-A)\\
&首先有：(\lambda_iI-A)\times(\lambda_j I-A)=\lambda_i\lambda_jI^2-(\lambda_i+\lambda_j)IA+A^2=(\lambda_jI-A)\times(\lambda_i I-A)\\
&我们只要证明f(A)乘任何特征向量都会得到0矩阵，就可以说明矩阵A=0\\
&f(A)\times \overrightarrow {v_i}=\prod_{j\ne i}(\lambda_jI-A)(\lambda_i I-A)\overrightarrow {v_i}=\prod_{j\ne i}(\lambda_jI-A)\times 0=0\\
&\therefore f(A)=0
\end{align}
$$
</div>
<div class = "MarkdownCommonContent">
<h3 class = "MarkdownH3">
优化递推：
</h3>
</div>
<div class = "MarkdownCommonContent">
设转移矩阵为
$M$
，根据矩阵快速幂，我们只要能求出来
$M^n$
就行了。
</div>
<div class = "MarkdownCommonContent">
$x^n$
可以看作一个
$n$
次多项式，那么我们用
$f(x)$
来表示就是
$x^n=f(x)\times g(x)+h(x)$
。
</div>
<div class = "MarkdownCommonContent">
即
$M^n=f(M)\times g(M)+h(M)$
，但是由于
$f(M)=0$
，因此：
$M^n=h(M)$
，于是我们可以倍增：也就是每次
$H(n)=h(n)\times h(n)$
，但是
$H(n)$
是
$2k-2$
次的，因此我们可以手动多项式取模，复杂度
$O(k^2\log n)$
，如果用
$FFT$
卷积
$+$
多项式除法可以做到
$O(k\log k\log n)$
。
</div>
<div class = "MarkdownCommonContent">
还有一个问题，就是
$f(x)$
怎么求，手动模拟一下求行列式的过程会发现
$[x^i]f(x)=-a[k-i],[x^k]f(x)=1$
。
</div>
<div class = "MarkdownCommonContent">
总之当个板子记住就行了。
</div>
<div class = "MarkdownCommonContent">
<h3 class = "MarkdownH3">
Code：
</h3>
</div>
<div class = "MarkdownCommonContent">
暴力取模：
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n,k;<br />
#define MAXK 4010<br />
#define MOD 1000000007<br />
inline int rd()<br />
{<br />
	register int res = 0,f = 1;register char c = getchar();<br />
	while(!isdigit(c)){if(c == '-')f = -1;c = getchar();}<br />
	while(isdigit(c))res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - '0',c = getchar();<br />
	return res * f;<br />
}<br />
int f[MAXK],h[MAXK];<br />
struct poly<br />
{<br />
	int a[MAXK];<br />
	poly(){memset(a,0,sizeof(a));}<br />
	int& operator [](const int &i){return a[i];}<br />
	int operator [](const int &i)const{return a[i];}<br />
	inline poly operator * (const poly &b)<br />
	{<br />
		poly res;<br />
		for(register int i = 0;i &lt; k;++i)<br />
			for(register int j = 0;j &lt; k;++j)<br />
				(res[i + j] += 1ll * a[i] * b[j] % MOD) %= MOD;<br />
		for(register int i = 2 * k - 2;i &gt;= k;res[i--] = 0)<br />
			for(register int j = 1;j &lt;= k;++j)<br />
				(res[i - j] += 1ll * res[i] * f[j] % MOD) %= MOD;<br />
		return res;<br />
	}<br />
}m;<br />
poly power(poly a,int b)<br />
{<br />
	register poly res;<br />
	res[0] = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a;<br />
		a = a * a;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
int main()<br />
{<br />
	scanf("%d%d",&n,&k);<br />
	for(register int i = 1;i &lt;= k;++i)f[i] = rd(),f[i] = (f[i] &gt; 0 ? f[i] : f[i] + MOD);<br />
	for(register int i = 0;i &lt; k;++i)h[i] = rd(),h[i] = (h[i] &gt; 0 ? h[i] : h[i] + MOD);<br />
	if(n &lt; k){cout &lt;&lt; h[n] &lt;&lt; endl;return 0;}<br />
	m[1] = 1;int ans = 0;<br />
	m = power(m,n);<br />
	for(register int i = 0;i &lt; k;++i)(ans += 1ll * m[i] * h[i] % MOD) %= MOD;<br />
	cout &lt;&lt; ans &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
$FFT$
卷积
$+$
多项式取模：
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n,k;<br />
#define MAXK 248000<br />
#define MOD 998244353<br />
inline int rd()<br />
{<br />
	register int res = 0,f = 1;register char c = getchar();<br />
	while(!isdigit(c)){if(c == '-')f = -1;c = getchar();}<br />
	while(isdigit(c))res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - '0',c = getchar();<br />
	return res * f;<br />
}<br />
int f_[MAXK],h[MAXK];<br />
namespace polynomial<br />
{ <br />
	int rev[MAXK];<br />
	int ww[MAXK &lt;&lt; 1],*g = ww + MAXK;<br />
	int power(int a,int b)<br />
	{<br />
		int res = 1;<br />
		while(b &gt; 0)<br />
		{<br />
			if(b & 1)res = 1ll * res * a % MOD;<br />
			a = 1ll * a * a % MOD;<br />
			b = b &gt;&gt; 1;<br />
		}<br />
		return res;<br />
	}<br />
	int init(int n)<br />
	{<br />
		int l = 0,len = 1;<br />
		for(;len &lt;= n;len = len &lt;&lt; 1)++l;<br />
		for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
		g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(MOD - 1) / len);<br />
		for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % MOD;<br />
		return len;<br />
	}<br />
	struct poly<br />
	{<br />
		int a[MAXK];<br />
		int d;<br />
		poly(){memset(a,0,sizeof(a));d = 0;}<br />
		int& operator [](int x){return a[x];}<br />
		int operator [](int x)const{return a[x];}<br />
	};<br />
	void NTT(poly &f,int l,int type)<br />
	{<br />
		for(int i = 0;i &lt; l;++i)<br />
		{<br />
			if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
		}<br />
		for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
		{<br />
			int wn = g[type * l / i];<br />
			for(int j = 0;j &lt; l;j += i)<br />
			{<br />
				int w = 1;<br />
				for(int k = j;k &lt; j + i / 2;++k)<br />
				{<br />
					int u = f[k],t = 1ll * w * f[k + i / 2] % MOD;<br />
					f[k] = (u + t) % MOD;<br />
					f[k + i / 2] = (u - t + MOD) % MOD;<br />
					w = 1ll * w * wn % MOD;<br />
				}<br />
			}<br />
		}<br />
		if(type == -1)<br />
		{<br />
			int ni = power(l,MOD - 2);<br />
			for(int i = 0;i &lt; l;++i)f[i] = 1ll * f[i] * ni % MOD;<br />
		}<br />
		return;<br />
	}<br />
	poly operator * (poly a,poly b)<br />
	{<br />
		poly res;<br />
		int len = init(a.d + b.d);res.d = a.d + b.d;<br />
		NTT(a,len,1);NTT(b,len,1);<br />
		for(int i = 0;i &lt; len;++i)res[i] = 1ll * a[i] * b[i] % MOD;<br />
		NTT(res,len,-1);<br />
		return res;<br />
	}<br />
	poly invtmp;<br />
	void calc_inv(poly &a,poly &b,int deg)<br />
	{<br />
		if(deg == 1){b[0] = power(a[0],MOD - 2);return;}<br />
		calc_inv(a,b,((deg + 1) &gt;&gt; 1));<br />
		int len = init(deg &lt;&lt; 1);<br />
		for(int i = 0;i &lt; deg;++i)invtmp[i] = a[i];<br />
		for(int i = deg;i &lt; len;++i)invtmp[i] = 0;<br />
		NTT(invtmp,len,1);NTT(b,len,1);<br />
		for(int i = 0;i &lt; len;++i)<br />
		{<br />
			b[i] = (2ll * b[i] % MOD - 1ll * invtmp[i] * b[i] % MOD * b[i] % MOD + MOD) % MOD;<br />
		}<br />
		NTT(b,len,-1);<br />
		for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
		b.d = deg - 1;<br />
		return;<br />
	}<br />
	poly operator + (poly a,poly b)<br />
	{<br />
		poly res;<br />
		res.d = max(a.d,b.d);<br />
		for(int i = 0;i &lt; res.d;++i)res[i] = (a[i] + b[i]) % MOD;<br />
		return res;<br />
	}<br />
	poly operator - (poly a,poly b)<br />
	{<br />
		poly res;<br />
		res.d = max(a.d,b.d);<br />
		for(int i = 0;i &lt; res.d;++i)res[i] = (a[i] - b[i] + MOD) % MOD;<br />
		return res;<br />
	}<br />
	poly divtmp;<br />
	poly operator / (poly a,poly b)<br />
	{<br />
		for(int i = 0;i &lt;= divtmp.d;++i)divtmp[i] = 0;<br />
		for(int i = 0,j = a.d;i &lt; j;++i,--j)swap(a[i],a[j]);<br />
		for(int i = 0,j = b.d;i &lt; j;++i,--j)swap(b[i],b[j]);<br />
		calc_inv(b,divtmp,b.d + 1);<br />
		divtmp = divtmp * a;<br />
		for(int i = a.d - b.d + 1;i &lt;= divtmp.d;++i)divtmp[i] = 0;<br />
		divtmp.d = a.d - b.d;<br />
		for(int i = 0,j = divtmp.d;i &lt; j;++i,--j)swap(divtmp[i],divtmp[j]);<br />
		return divtmp;<br />
	}<br />
	poly operator % (poly a,poly b)<br />
	{<br />
		poly res = a - a / b * b;<br />
		res.d = b.d - 1;<br />
		return res;<br />
	}<br />
}<br />
using namespace polynomial;<br />
poly f;<br />
struct matrix<br />
{<br />
	poly a;<br />
	int& operator [](int x){return a[x];}<br />
	int operator [](int x)const{return a[x];}<br />
	friend inline matrix operator * (matrix a,matrix b)<br />
	{<br />
		matrix res;<br />
		res.a = a.a * b.a;<br />
		res.a = res.a % f;<br />
		return res;<br />
	}<br />
}m;<br />
matrix power(matrix a,int b)<br />
{<br />
	matrix res;<br />
	res[0] = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a;<br />
		a = a * a;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
int main()<br />
{<br />
	scanf("%d%d",&n,&k);<br />
	for(register int i = 1;i &lt;= k;++i)f_[i] = rd(),f_[i] = (f_[i] &gt; 0 ? f_[i] : f_[i] + MOD);<br />
	for(register int i = 0;i &lt; k;++i)h[i] = rd(),h[i] = (h[i] &gt; 0 ? h[i] : h[i] + MOD);<br />
	if(n &lt; k){cout &lt;&lt; h[n] &lt;&lt; endl;return 0;}<br />
	f[k] = 1;<br />
	for(int i = 0;i &lt; k;++i)f[i] = MOD - f_[k - i];<br />
	f.d = k;<br />
	m[1] = 1;m.a.d = k - 1;int ans = 0;<br />
	m = power(m,n);<br />
	ans = 0;<br />
	for(int i = 0;i &lt; k;++i)(ans += 1ll * m[i] * h[i] % MOD) %= MOD;<br />
	cout &lt;&lt; ans &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式多点求值
</h2>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式快速插值
</h2>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式辗转相除法
</h2>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式求导和积分
</h2>
</div>
<div class = "MarkdownCommonContent">
求导：
$$
(x^a)'=ax^{a-1}
$$
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
for(int i = 1;i &lt; n;++i)f[i - 1] = 1ll * i * f[i] % P;<br />
f[n - 1] = 0;<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
不定积分：
$$
\int^x_0 t^adt=\frac1{a+1}x^{a+1}
$$
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
for(int i = n - 1;i &gt;= 1;--i)f[i] = 1ll * f[i - 1] * power(i,P - 2) % P;<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式对数函数
</h2>
</div>
<div class = "MarkdownCommonContent">
求
$g(x)=\ln f(x)$
。
</div>
<div class = "MarkdownCommonContent">
对两边同时求导，得：
$$
g'(x)=(\ln f(x))'=\ln'f(x)f'(x)=\frac{f'(x)}{f(x)}
$$
所以就先对
$f$
求导除以
$f$
的逆然后再不定积分就可以了。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 400010<br />
int f[MAXN],f_[MAXN];<br />
#define P 998244353<br />
int ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
int rev[MAXN];<br />
int a[MAXN],b[MAXN],c[MAXN];<br />
int power(int a,int b)<br />
{<br />
	int res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = 1ll * res * a % P;<br />
		a = 1ll * a * a % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void NTT(int f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		int wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			int w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				int u = f[k],t = 1ll * w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = 1ll * w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		int ni = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)f[i] = 1ll * f[i] * ni % P;<br />
	}<br />
	return;<br />
}<br />
void calc_inv(int deg,int a[],int b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2);<br />
		return;<br />
	}<br />
	calc_inv((deg + 1) &gt;&gt; 1,a,b);<br />
	int l = 0,len = 1;<br />
	for(;len &lt; (deg &lt;&lt; 1);len = len &lt;&lt; 1,++l);<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt;= len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; deg;++i)c[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)c[i] = 0;<br />
	NTT(c,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = (2 * b[i] % P - 1ll * c[i] * b[i] % P * b[i] % P + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 0;i &lt; n;++i)scanf("%d",&f[i]);<br />
	calc_inv(n,f,f_);<br />
	//for(int i = 0;i &lt; n;++i)cout &lt;&lt; f_[i] &lt;&lt; " ";cout &lt;&lt; endl;<br />
	for(int i = 1;i &lt; n;++i)f[i - 1] = 1ll * i * f[i] % P;<br />
	//for(int i = 0;i &lt; n;++i)cout &lt;&lt; f[i] &lt;&lt; " ";cout &lt;&lt; endl;<br />
	f[n - 1] = 0;<br />
	int l = 0,len = 1;<br />
	for(;len &lt;= (n &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	NTT(f,len,1);NTT(f_,len,1);<br />
	for(int i = 0;i &lt; len;++i)f[i] = 1ll * f[i] * f_[i] % P;<br />
	NTT(f,len,-1);<br />
	for(int i = n - 1;i &gt;= 1;--i)f[i] = 1ll * f[i - 1] * power(i,P - 2) % P;<br />
	f[0] = 0;<br />
	for(int i = 0;i &lt; n;++i)printf("%d ",f[i]);cout &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式指数函数
</h2>
</div>
<div class = "MarkdownCommonContent">
要求：
$$
F(x)=e^{H(x)}
$$
两边取对数：
$$
\ln(F(x))-H(x)=0
$$
设
$G(F(x))=\ln(F(x))-H(x)$
</div>
<div class = "MarkdownCommonContent">
根据牛顿迭代有：
$$
F(x)=F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}
$$
在这里
$H(x)$
其实就是常数项，于是：
$$
G'(F(x))=\frac{1}{F(x)}
$$
那么也就是说：
$$
\begin{align}
F(x)&=F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\\
&=F_0(x)-(\ln(F_0(x))+H(x))F_0(x)\\
&=F_0(x)(1-\ln(F_0(x))+H(x))
\end{align}
$$
于是多项式求对数就行了。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 800010<br />
typedef long long ll;<br />
ll h[MAXN];<br />
#define P 998244353<br />
ll power(ll a,ll b)<br />
{<br />
	ll res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a % P;<br />
		a = a * a % P;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
void diff(int deg,ll a[],ll b[])<br />
{<br />
	memset(b,0,sizeof(b));<br />
	for(int i = 1;i &lt; deg;++i)b[i - 1] = i * a[i] % P;<br />
	return;<br />
}<br />
void inte(int deg,ll a[],ll b[])<br />
{<br />
	memset(b,0,sizeof(b));<br />
	for(int i = deg - 1;i &gt;= 1;--i)b[i] = a[i - 1] * power(i,P - 2) % P;<br />
	return;<br />
}<br />
ll ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
int rev[MAXN];<br />
ll invtmp[MAXN];<br />
void NTT(ll f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		ll wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			ll w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		ll ni = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)f[i] = f[i] * ni % P;<br />
	}<br />
	return;<br />
} <br />
void calc_inv(int deg,ll a[],ll b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2);<br />
		return;<br />
	}<br />
	calc_inv((deg + 1) &gt;&gt; 1,a,b);<br />
	int l = 0,len = 1;<br />
	for(;len &lt;= (deg &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	for(int i = 0;i &lt; deg;++i)invtmp[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)invtmp[i] = 0;<br />
	NTT(invtmp,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = ((2 * b[i] % P) - (invtmp[i] * b[i] % P * b[i] % P) + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	return;<br />
}<br />
ll f_[MAXN];<br />
void mul(int deg,ll a[],ll b[])<br />
{<br />
	int l = 0,len = 1;<br />
	for(;len &lt;= (deg &lt;&lt; 1);len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(3,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	NTT(a,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		a[i] = a[i] * b[i] % P;<br />
	}<br />
	NTT(a,len,-1);NTT(b,len,-1);<br />
	return;<br />
}<br />
ll lntmp[MAXN];<br />
void calc_ln(int deg,ll a[],ll b[])<br />
{<br />
	diff(deg,a,f_);<br />
	memset(lntmp,0,sizeof(lntmp));<br />
	calc_inv(deg,a,lntmp);<br />
	mul(deg,f_,lntmp);<br />
	inte(deg,f_,b);<br />
	return;<br />
}<br />
ll res[MAXN];<br />
ll exptmp[MAXN];<br />
void calc_exp(int deg,ll a[],ll b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = 1;<br />
		return;<br />
	}<br />
	calc_exp((deg + 1) &gt;&gt; 1,a,b);<br />
	calc_ln(deg,b,exptmp);<br />
	for(int i = 0;i &lt; deg;++i)exptmp[i] = (a[i] - exptmp[i] + P) % P;<br />
	exptmp[0] = (exptmp[0] + 1) % P;<br />
	mul(deg,b,exptmp);<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 0;i &lt; n;++i)scanf("%lld",&h[i]);<br />
	calc_exp(n &lt;&lt; 1,h,res);<br />
	for(int i = 0;i &lt; n;++i)printf("%lld ",res[i]);cout &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式快速幂
</h2>
</div>
<div class = "MarkdownCommonContent">
显然可以暴力倍增，但是这样的复杂度是
$O(n\log^2n)$
的，我们希望找到更优秀的做法。
$$
F^k=\exp(k\ln F)
$$
于是先求
$\ln$
乘个
$k$
再
$\exp$
回去就行了。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n,s;<br />
#define MAXN 400010<br />
#define P 998244353 <br />
#define G 3 <br />
int a[MAXN],b[MAXN],c[MAXN];<br />
#define I inline<br />
#define R register<br />
int rev[MAXN];<br />
int ww[MAXN &lt;&lt; 1],*g = ww + MAXN;<br />
int power(int a,int b)<br />
{<br />
	int res = 1;<br />
	for(;b &gt; 0;a = 1ll * a * a % P,b = b &gt;&gt; 1)if(b & 1)res = 1ll * res * a % P;<br />
	return res;<br />
}<br />
int inver(int a){return power(a,P - 2);}<br />
int init(int n)<br />
{<br />
	int l = 0,len = 1;<br />
	for(;len &lt;= n;len = len &lt;&lt; 1)++l;<br />
	for(int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	g[0] = g[-len] = 1;g[1] = g[1 - len] = power(G,(P - 1) / len);<br />
	for(int i = 2;i &lt; len;++i)g[i] = g[i - len] = 1ll * g[i - 1] * g[1] % P;<br />
	return len;<br />
}<br />
void NTT(int f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		int wn = g[type * l / i];<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			int w = 1;<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				int u = f[k],t = 1ll * w * f[k + i / 2] % P;<br />
				f[k] = (u + t) % P;<br />
				f[k + i / 2] = (u - t + P) % P;<br />
				w = 1ll * w * wn % P;<br />
			}<br />
		}<br />
	}<br />
	if(type == -1)<br />
	{<br />
		int ni = power(l,P - 2);<br />
		for(int i = 0;i &lt; l;++i)f[i] = 1ll * f[i] * ni % P;<br />
	}<br />
	return;<br />
}<br />
int invtmp[MAXN];<br />
void calc_inv(int deg,int a[],int b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = power(a[0],P - 2);<br />
		return;<br />
	}<br />
	calc_inv(((deg + 1) &gt;&gt; 1),a,b);<br />
	int len = init(deg * 2);<br />
	for(int i = 0;i &lt; deg;++i)invtmp[i] = a[i];<br />
	for(int i = deg;i &lt; len;++i)invtmp[i] = 0;<br />
	NTT(invtmp,len,1);NTT(b,len,1);<br />
	for(int i = 0;i &lt; len;++i)<br />
	{<br />
		b[i] = (2ll * b[i] - 1ll * invtmp[i] * b[i] % P * b[i] % P + P) % P;<br />
	}<br />
	NTT(b,len,-1);<br />
	for(int i = deg;i &lt; len;++i)b[i] = 0;<br />
	return;<br />
}<br />
int lnt[MAXN];<br />
void poly_ln(int deg,int a[],int b[])<br />
{<br />
	calc_inv(deg,a,b);<br />
	for(int i = 0;i &lt; deg;++i)lnt[i] = a[i];<br />
	for(int i = 0;i &lt; deg;++i)lnt[i] = 1ll * (i + 1) * lnt[i + 1] % P;<br />
	int l = init(deg * 2);<br />
	NTT(lnt,l,1);NTT(b,l,1);<br />
	for(int i = 0;i &lt; l;++i)lnt[i] = 1ll * lnt[i] * b[i] % P;<br />
	NTT(lnt,l,-1);<br />
	for(int i = deg;i &gt; 0;--i)lnt[i] = 1ll * inver(i) * lnt[i - 1] % P;lnt[0] = 0;<br />
	for(int i = 0;i &lt; deg;++i)b[i] = lnt[i];<br />
	for(int i = deg;i &lt; l;++i)b[i] = 0;<br />
	for(int i = 0;i &lt; l;++i)lnt[i] = 0; <br />
	return;<br />
}<br />
int expt[MAXN];<br />
void poly_exp(int deg,int a[],int b[])<br />
{<br />
	if(deg == 1)<br />
	{<br />
		b[0] = 1;<br />
		return; <br />
	}<br />
	poly_exp((deg + 1) &gt;&gt; 1,a,b);<br />
	poly_ln(deg,b,expt);<br />
	for(int i = 0;i &lt; deg;++i)expt[i] = (a[i] - expt[i] + P) % P;<br />
	expt[0] = (expt[0] + 1) % P;<br />
	int l = init(deg * 2);<br />
	NTT(expt,l,1);NTT(b,l,1);<br />
	for(int i = 0;i &lt; l;++i)expt[i] = 1ll * expt[i] * b[i] % P;<br />
	NTT(expt,l,-1);<br />
	for(int i = 0;i &lt; deg;++i)b[i] = expt[i];<br />
	for(int i = deg;i &lt; l;++i)b[i] = 0;<br />
	for(int i = 0;i &lt; l;++i)expt[i] = 0;<br />
	return;<br />
}<br />
int rd()<br />
{<br />
	register int res = 0;register char c = getchar();<br />
	while(!isdigit(c))c = getchar();<br />
	while(isdigit(c))res = (10ll * res % P + c - '0') % P,c = getchar();<br />
	return res;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	s = rd();<br />
	for(int i = 0;i &lt; n;++i)scanf("%d",&a[i]);<br />
	poly_ln(n,a,b);<br />
	for(int i = 0;i &lt; n;++i)b[i] = 1ll * b[i] * s % P;<br />
	poly_exp(n,b,c);<br />
	for(int i = 0;i &lt; n;++i)printf("%d ",c[i]);<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式三角函数
</h2>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
多项式求复合逆
</h2>
</div>
<div class = "MarkdownCommonContent">
复合逆：如果两个多项式
$F(x)$
和
$G(x)$
满足都没有常数项且一次项系数互为逆元，并且：
$F(G(x))=x$
那么称
$F(x)$
为
$G(x)$
的复合逆，并且一定满足
$F(G(x))=G(F(x))$
。
</div>
<div class = "MarkdownCommonContent">
求复合逆没有
$O(n\log n)$
求
$[1,n]$
的值的方法，但是我们可以
$O(n\log n)$
的求出单点的值：
$$
[x^n]F(x)=\frac1n[x^{n-1}](\frac x{G(x)})^n
$$
这个又称为拉格朗日反演。
</div>
<div class = "MarkdownCommonContent">
另外一个扩展拉格朗日反演：
$$
[x^n]H(F(x))=\frac1nH'(x)(\frac xG(x))^n
$$
所以只用多项式
$\ln+\exp$
即可。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
任意模数FFT
</h2>
</div>
<div class = "MarkdownCommonContent">
任意模数FFT有两种写法，其中第一种常数大，因此我们在此只考虑第二种写法。
</div>
<div class = "MarkdownCommonContent">
首先如果最初的数
$\in[0,N]$
，那么
$FFT$
之后的数不会超过
$N^3$
，考虑卷积的式子就行了。
</div>
<div class = "MarkdownCommonContent">
设模数为
$M$
，设
$M_o=\sqrt M$
，那么我们可以将参与卷积的所有整数表示为
$x=a[x]M_0+b[x]$
，其中
$a[x]$
和
$b[x]$
都是整数，那么可以发现：
$$
 x\times y=(a[x]M_0+b[x])\times (a[y]M_0+b[y])=a[x]a[y]M_0^2+a[x]b[y]M_0+a[y]b[x]M_0+b[x]b[y]
$$
也就是说：
$$
\begin{align}
&\sum_{i=0}^nx[i]\times y[n-i]\\
=&M_0^2\sum_{i=0}^na[x[i]]a[y[n-i]]+M_0\sum_{i=0}^na[x[i]]b[y[n-i]]+M_0\sum_{i=0}^na[y[n-i]]b[x[i]]+\sum_{i=0}^nb[x[i]]b[y[n-i]]\\
\end{align}
$$
发现这其实就是四个卷积，所以我们可以分开做，对应系数相同的合在一起
$IDFT$
，一共需要
$4$
次
$DFT$
和
$3$
次
$IDFT$
，一共七次。
</div>
<div class = "MarkdownCommonContent">
可以用一种奇技淫巧优化成4次。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
struct comp<br />
{<br />
	long double r,i;<br />
	comp(long double r_ = 0,long double i_ = 0){r = r_;i = i_;}<br />
};<br />
I comp operator + (comp a,comp b){return comp(a.r + b.r,a.i + b.i);}<br />
I comp operator - (comp a,comp b){return comp(a.r - b.r,a.i - b.i);}<br />
I comp operator * (comp a,comp b){return comp(a.r * b.r - a.i * b.i,a.r * b.i + a.i * b.r);}<br />
int rev[MAXN];<br />
I int init(int n)<br />
{<br />
	R int l = 0,len = 1;<br />
	for(;len &lt;= n;len = len &lt;&lt; 1)++l;<br />
	for(R int i = 0;i &lt; len;++i)rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i & 1) &lt;&lt; (l - 1));<br />
	return len;<br />
}<br />
const long double PI = acos(-1);<br />
I void FFT(comp f[],int l)<br />
{<br />
	for(R int i = 0;i &lt; l;++i)<br />
	{<br />
		if(i &lt; rev[i])swap(f[i],f[rev[i]]);<br />
	}<br />
	for(R int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		comp wn = comp(cos(PI * 2 / i),sin(PI * 2 / i));<br />
		for(R int j = 0;j &lt; l;j += i)<br />
		{<br />
			comp w = comp(1,0);<br />
			for(R int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				comp u = f[k],t = w * f[k + i / 2];<br />
				f[k] = u + t;<br />
				f[k + i / 2] = u - t;<br />
				w = w * wn;<br />
			}<br />
		}<br />
	}<br />
	return;<br />
}<br />
comp a[MAXN],b[MAXN];<br />
comp r1[MAXN],r2[MAXN],r3[MAXN],r4[MAXN];<br />
typedef long long ll;<br />
comp conj(comp k){return comp(k.r,-k.i);}<br />
I void mul(int x[],int y[],int r[],int l)<br />
{<br />
	for(R int i = 0;i &lt; l;++i)a[i] = comp(x[i] & 32767,x[i] &gt;&gt; 15);<br />
	for(R int i = 0;i &lt; l;++i)b[i] = comp(y[i] & 32767,y[i] &gt;&gt; 15);<br />
	FFT(a,l);FFT(b,l);<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		int j = (l - i) & (l - 1);<br />
		comp da,db,dc,dd;<br />
		da = (a[i] + conj(a[j])) * comp(0.5,0);<br />
		db = (a[i] - conj(a[j])) * comp(0,-0.5);<br />
		dc = (b[i] + conj(b[j])) * comp(0.5,0);<br />
		dd = (b[i] - conj(b[j])) * comp(0,-0.5);<br />
		r1[j] = da * dc;<br />
		r2[j] = da * dd;<br />
		r3[j] = db * dc;<br />
		r4[j] = db * dd;<br />
	}<br />
	for(int i = 0;i &lt; l;++i)a[i] = r1[i] + r2[i] * comp(0,1);<br />
	for(int i = 0;i &lt; l;++i)b[i] = r3[i] + r4[i] * comp(0,1);<br />
	FFT(a,l);FFT(b,l);<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		int da = (ll)(a[i].r / l + 0.5) % p;<br />
		int db = (ll)(a[i].i / l + 0.5) % p;<br />
		int dc = (ll)(b[i].r / l + 0.5) % p;<br />
		int dd = (ll)(b[i].i / l + 0.5) % p;<br />
		r[i] = (da + ((ll)(db + dc) &lt;&lt; 15) + ((ll)dd &lt;&lt; 30)) % p;<br />
	}<br />
	return;<br />
} <br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
快速莫比乌斯变换
</h2>
</div>
<div class = "MarkdownCommonContent">
<img class = "MarkdownImg" src="https://images2018.cnblogs.com/blog/922029/201807/922029-20180709193119680-196786520.gif"  alt="" />
</div>
<div class = "MarkdownCommonContent">
快速莫比乌斯变换是用来解决集合幂级数的集合并卷积的问题，也就是说，给定两个长度为
$2^n-1$
的序列
$a$
和
$b$
，让求一个序列
$c$
满足：
$$
c[k]=\sum_{i\text{ or }j=k}a[i]\times b[j]
$$
暴力做肯定是
$O((2^n)^2)$
的，考虑怎么优化，
$i\cup j=k$
这个很不好处理，那么我们可以做一个集合的前缀和（用大写字母表示）：
$$
\begin{align}
C[k]&=\sum_{k_0\subseteq k}c[k_0]\\
&=\sum_{k_0\subseteq k}\sum_{i\cup j=k_0}a[i]\times b[j]\\
&=\sum_{i\cup j\subseteq k}a[i]\times b[j]\\
&=(\sum_{i\subseteq k}a[i])\times (\sum_{j\subseteq k}b[j])\\
&=A[k]\times B[k]
\end{align}
$$
也就是说快速莫比乌斯变换就是用来求集合的前缀和的，可以理解为它的本质是一个每一维都只有
$0/1$
的高位前缀和，也可以理解为按位分治，在这个求完之后像
$FFT$
一样对应位置相乘，然后再逆变换回去即可，逆变换就是加变成减，代码不变。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
void FMT(ll f[],int l,int type)<br />
{<br />
	for(int i = 0;i &lt; l;++i)<br />
	{<br />
		for(int j = 0;j &lt; (1 &lt;&lt; l);++j)<br />
		{<br />
			if(((j &gt;&gt; i) & 1) == 0)f[j | (1 &lt;&lt; i)] = f[j | (1 &lt;&lt; i)] + type * f[j];<br />
		}<br />
	}<br />
	return;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
快速沃尔什-哈达玛变换
</h2>
</div>
<div class = "MarkdownCommonContent">
用于计算位运算卷积。
</div>
<div class = "MarkdownCommonContent">
先考虑异或卷积：
$$
c[k]=\sum_{i\text{ xor }j=k}a[i]\times b[j]
$$
有了
$FFT,NTT,FMT$
的经验，肯定是要构造一个变换，使得变换之后对应位置相乘再逆变换回去就是答案。
</div>
<div class = "MarkdownCommonContent">
在这里设所有的向量都是从
$0$
到
$2^n-1$
。
</div>
<div class = "MarkdownCommonContent">
定义：
$$
\begin{align}
A(x)+B(x)&=\{a[0]+b[0],a[1]+b[1],\dots,a[2^n-1]+b[2^n-1]\}\\
A(x)\times B(x)&=\{a[0]\times b[0],a[1]\times b[1],\dots,a[2^n-1]\times b[2^n-1]\}\\
A(x)\oplus B(x)&=C(x)\ \ C(x)就是我们要求的异或卷积\\
A_0(x)=\{a[0],&a[1],\dots,a[2^{n-1}-1]\},A_1(x)=\{a[2^{n-1}],a[2^{n-1}+1],\dots,a[2^n-1]\}
\end{align}
$$
那么我们定义变换（也叫
$FWT$
算子）
$tf$
：
$$
\begin{align}
tf(A)&=a_0,k=0\\
tf(A)&=(tf(A_0)+tf(A_1),tf(A_0)-tf(A_1))
\end{align}
$$
引理：
$$
tf(A+B)=tf(A)+tf(B)
$$
用数学归纳法证明：
$$
\begin{align}
tf(A+B)&=A+B=tf(A)+tf(B),k=0\\
tf(A+B)&=(tf(A_0+B_0)+tf(A_1+B_1),tf(A_0+B_0)-tf(A_1+B_1))\\
&=(tf(A_0)+tf(B_0)+tf(A_1)+tf(B_1),tf(A_0)+tf(B_0)-tf(A_1)-tf(B_1))\\
&=(tf(A_0)+tf(A_1),tf(A_0)-tf(A_1))+(tf(B_0)+tf(B_1),tf(B_0)-tf(B_1))\\
&=tf(A)+tf(B),k&gt;0
\end{align}
$$
接下来就是要证明：
$$
tf(A)\times tf(B)=tf(C)
$$
</div>
<div class = "MarkdownCommonContent">
还是要用数学归纳法，假设在
$k-1$
的情况成立：
$$
\begin{align}
tf(A)\times tf(B)&=(tf(A_0)+tf(A_1),tf(A_0)-tf(A_1))\times (tf(B_0)+tf(B_1),tf(B_0)-tf(B_1))\\
&=(tf(A_0)tf(B_0)+tf(A_1)tf(B_0)+tf(A_0)tf(B_1)+tf(A_1)tf(B_1))+\\
&\ \ \ \ \ (tf(A_0)tf(B_0)-tf(A_1)tf(B_0)-tf(A_0)tf(B_1)+tf(A_1)tf(B_1))\\
&=(tf(A_0\oplus B_0)+tf(A_1\oplus B_0)+tf(A_0\oplus B_1)+tf(A_1\oplus B_1))+\\
&\ \ \ \ \ (tf(A_0\oplus B_0)-tf(A_1\oplus B_0)-tf(A_0\oplus B_1)+tf(A_1\oplus B_1))\\
\\
tf(C)&=tf(A_0\oplus B_0+A_1\oplus B_1,A_0\oplus B_1+A_1\oplus B_0)\\
&=(tf(A_0\oplus B_0+A_1\oplus B_1)+tf(A_0\oplus B_1+A_1\oplus B_0),\\
&\ \ \ \ \ \ \ tf(A_0\oplus B_0+A_1\oplus B_1)-tf(A_0\oplus B_1+A_1\oplus B_0))\\
&=(tf(A_0\oplus B_0)+tf(A_1\oplus B_0)+tf(A_0\oplus B_1)+tf(A_1\oplus B_1))+\\
&\ \ \ \ \ (tf(A_0\oplus B_0)-tf(A_1\oplus B_0)-tf(A_0\oplus B_1)+tf(A_1\oplus B_1))\\
\end{align}
$$
得证。
</div>
<div class = "MarkdownCommonContent">
在定义逆变换
$utf$
，我们只要让
$utf(tf(C))=C$
就可以了。
$$
utf(C)=(\frac{utf(C_0+C_1)}{2},\frac{utf(C_0-C_1)}{2})
$$
证明：
$$
\begin{align}
utf(tf(C))&=(\frac{utf(tf(C)_0+tf(C)_1)}{2},\frac{utf(tf(C)_0-tf(C)_1)}{2})\\
&=(\frac{utf(tf(C_0)+tf(C_1)+tf(C_0)-tf(C_1))}{2},\frac{utf(tf(C_0)+tf(C_1)-tf(C_0)+tf(C_1))}{2})\\
&=(\frac{utf(2tf(C_0))}{2},\frac{utf(2tf(C_1))}{2})\\
\because&\ tf(A)+tf(B)=tf(A+B)\\
utf(tf(C))&=(\frac{utf(tf(2C_0))}{2},\frac{utf(tf(2C_1))}{2})\\
&=(\frac{2C_0}{2},\frac{2C_1}{2})\\
&=(C_0,C_1)\\
&=C
\end{align}
$$
于是按照这个变换求解即可。
</div>
<div class = "MarkdownCommonContent">
与卷积：
$tf(A)=(tf(A_0)+tf(A_1),tf(A_1)),utf(A)=(utf(A_0)-utf(A_1),utf(A_1))$
或卷积：
$tf(A)=(tf(A_0),tf(A_0)+tf(A_1)),utf(A)=(utf(A_0),utf(A_1)-utf(A_0))$
</div>
<div class = "MarkdownCommonContent">
注意或卷积是
$utf(A_1)-utf(A_0)$
而不是
$utf(A_0)-utf(A_1)$
。
</div>
<div class = "MarkdownCommonContent">
异或卷积的另一个重要性质：
$$
g[i]=\sum (-1)^{bitcount(i\text{ and }j)}f[j]
$$
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
#define MAXN 18<br />
typedef long long ll;<br />
ll a[1 &lt;&lt; MAXN],b[1 &lt;&lt; MAXN];<br />
ll res[1 &lt;&lt; MAXN];<br />
#define MOD 998244353<br />
#define INV2 499122177<br />
void FWT_or(ll f[],int l,int type)<br />
{<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = f[k + i / 2];<br />
				if(type == 1)f[k + i / 2] = (u + t) % MOD;<br />
				else f[k + i / 2] = (t - u + MOD) % MOD;<br />
			}<br />
		}<br />
	}<br />
	return;<br />
}<br />
void FWT_and(ll f[],int l,int type)<br />
{<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = f[k + i / 2];<br />
				if(type == 1)f[k] = (u + t) % MOD;<br />
				else f[k] = (u - t + MOD) % MOD;<br />
			}<br />
		}<br />
	}<br />
	return;<br />
}<br />
void FWT_xor(ll f[],int l,int type)<br />
{<br />
	for(int i = 2;i &lt;= l;i = i &lt;&lt; 1)<br />
	{<br />
		for(int j = 0;j &lt; l;j += i)<br />
		{<br />
			for(int k = j;k &lt; j + i / 2;++k)<br />
			{<br />
				ll u = f[k],t = f[k + i / 2];<br />
				f[k] = (u + t) % MOD;<br />
				f[k + i / 2] = (u - t + MOD) % MOD;<br />
				if(type == -1)<br />
				{<br />
					f[k] = f[k] * INV2 % MOD;<br />
					f[k + i / 2] = f[k + i / 2] * INV2 % MOD;<br />
				}<br />
			}<br />
		}<br />
	}<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)scanf("%d",&a[i]);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)scanf("%d",&b[i]);<br />
	FWT_or(a,1 &lt;&lt; n,1);FWT_or(b,1 &lt;&lt; n,1);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)res[i] = a[i] * b[i] % MOD;<br />
	FWT_or(res,1 &lt;&lt; n,-1);FWT_or(a,1 &lt;&lt; n,-1);FWT_or(b,1 &lt;&lt; n,-1);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)printf("%lld ",res[i]);puts("");<br />
	FWT_and(a,1 &lt;&lt; n,1);FWT_and(b,1 &lt;&lt; n,1);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)res[i] = a[i] * b[i] % MOD;<br />
	FWT_and(res,1 &lt;&lt; n,-1);FWT_and(a,1 &lt;&lt; n,-1);FWT_and(b,1 &lt;&lt; n,-1);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)printf("%lld ",res[i]);puts("");<br />
	FWT_xor(a,1 &lt;&lt; n,1);FWT_xor(b,1 &lt;&lt; n,1);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)res[i] = a[i] * b[i] % MOD;<br />
	FWT_xor(res,1 &lt;&lt; n,-1);FWT_xor(a,1 &lt;&lt; n,-1);FWT_xor(b,1 &lt;&lt; n,-1);<br />
	for(int i = 0;i &lt; (1 &lt;&lt; n);++i)printf("%lld ",res[i]);puts("");<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
拉格朗日插值法
</h2>
</div>
<div class = "MarkdownCommonContent">
根据常识，给定
$n+1$
个点的值可以唯一确定一个
$n$
次多项式，拉格朗日插值法就是用点值还原系数的一种方法。
</div>
<div class = "MarkdownCommonContent">
定义
<strong class = "MarkdownStrong">
拉格朗日基本多项式
</strong>
（也叫
<strong class = "MarkdownStrong">
插值基函数
</strong>
）
$\ell(x)$
为：
$$
\ell_i(x)=\prod_{j=0,j\ne i}^n\frac{x-x_j}{x_i-x_j}=\frac{x-x_0}{x_i-x_0}\times\cdots\frac{x-x_{i-1}}{x_i-x_{i-1}}\times\frac{x-x_{i+1}}{x_i-x_{i+1}}\times\cdots\frac{x-x_n}{x_i-x_n}
$$
拉格朗日基本多项式的性质是只有当
$x=x_i$
时
$\ell_i(x)=1$
，
$x=x_j(j\ne i)$
时
$\ell_i(x)=0$
。
</div>
<div class = "MarkdownCommonContent">
那么我们就可以利用这个多项式构造插值公式：
$$
L(x)=\sum_{i=0}^ny_i\ell_i(x)
$$
通过拉格朗日插值法可以
$O(n^2)$
的单点求值。
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
int n;<br />
typedef long long ll;<br />
ll k;<br />
#define MAXN 2010<br />
ll x[MAXN],y[MAXN];<br />
#define MOD 998244353<br />
ll power(ll a,ll b)<br />
{<br />
	ll res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a % MOD;<br />
		a = a * a % MOD;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
ll inv(ll k){return power(k,MOD - 2);}<br />
ll lagrange(ll k)<br />
{<br />
	ll ans = 0;<br />
	for(int i = 1;i &lt;= n;++i)<br />
	{<br />
		ll res = y[i];<br />
		for(int j = 1;j &lt;= n;++j)<br />
		{<br />
			if(i == j)continue;<br />
			res = res * (k - x[j] + MOD) % MOD;<br />
			res = res * inv(x[i] - x[j] + MOD) % MOD;<br />
		}<br />
		ans = (ans + res) % MOD;<br />
	}<br />
	return ans;<br />
}<br />
int main()<br />
{<br />
	scanf("%d%lld",&n,&k);<br />
	for(int i = 1;i &lt;= n;++i)<br />
	{<br />
		scanf("%lld%lld",&x[i],&y[i]);<br />
	}<br />
	cout &lt;&lt; lagrange(k) &lt;&lt; endl;<br />
	return 0;<br />
}<br />
</pre></code>
</div>
<div class = "MarkdownCommonContent">
也可以
$O(n^2)$
的求原函数，具体做法是首先看拉格朗日插值的式子：
$$
f(x)=\sum_{i=1}^n\prod_{j=1,i\ne j}^n\frac{x-x_j}{x_i-x_j}y_i
$$
设
$w=\prod\limits_{j=1}^n(x-x_j)$
，那么：
$$
f(x)=\sum_{i=1}^n\frac w{x-x_i}a_i
$$
显然可以
$O(n^2)$
计算出所有的
$a_i$
，难的是分子部分，我们可以先计算出
$w$
，这个是
$O(n^2)$
的，然后每次做除法：
</div>
<div class = "MarkdownCommonContent">
设
$F\times (x-x_i)=w$
，那么有：
$w[k]=F[k-1]-x_i\times F[k]$
，移一下项就是：
$$
F[k]=(F[k-1]-w[k])/x_i
$$
特殊的：
$w[0]=-F[0]\times x_i$
，因此一个个推过去就行了。
</div>
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
typedef unsigned int uint;<br />
int n;<br />
#define MAXN 1700<br />
uint val[MAXN],res[MAXN],val_[MAXN];<br />
#define MOD 64123<br />
uint power(uint a,int b)<br />
{<br />
	uint res = 1;<br />
	while(b &gt; 0)<br />
	{<br />
		if(b & 1)res = res * a % MOD;<br />
		a = a * a % MOD;<br />
		b = b &gt;&gt; 1;<br />
	}<br />
	return res;<br />
}<br />
uint inv(uint k){return power(k,MOD - 2);}<br />
void calc(uint res[MAXN],uint val[MAXN],int n)<br />
{<br />
	uint w[MAXN],a[MAXN];<br />
	w[0] = 1;<br />
	for(int i = 1;i &lt;= n;++i)<br />
	{<br />
		a[i] = val[i];<br />
		for(int j = 1;j &lt;= n;++j)<br />
		{<br />
			if(i == j)continue;<br />
			a[i] = a[i] * inv((i - j + MOD) % MOD) % MOD;<br />
		}<br />
	}<br />
	for(int i = 1;i &lt;= n;++i)<br />
	{<br />
		for(int j = n;j &gt;= 0;--j)w[j] = (w[j - 1] - i * w[j] % MOD + MOD) % MOD;<br />
	}<br />
	uint tmp[MAXN];<br />
	for(int i = 1;i &lt;= n;++i)<br />
	{<br />
		tmp[0] = (-w[0] + MOD) % MOD * inv(i) % MOD;<br />
		for(int j = 1;j &lt; n;++j)tmp[j] = (tmp[j - 1] - w[j] + MOD) % MOD * inv(i) % MOD;<br />
		for(int j = 0;j &lt; n;++j)tmp[j] = tmp[j] * a[i] % MOD;<br />
		for(int j = 0;j &lt; n;++j)res[j] = (res[j] + tmp[j]) % MOD;<br />
	}<br />
	return;<br />
}<br />
int main()<br />
{<br />
	scanf("%d",&n);<br />
	for(int i = 1;i &lt;= n;++i)scanf("%d",&val[i]);<br />
	calc(res,val,n);<br />
	for(int i = 0;i &lt; n;++i)cout &lt;&lt; res[i] &lt;&lt; " ";cout &lt;&lt; endl;<br />
	for(int i = 1;i &lt;= n;++i)<br />
	{<br />
		uint ans = 0;<br />
		for(int j = 0,cur = 1;j &lt; n;++j)<br />
		{<br />
			ans = (ans + cur * res[j] % MOD) % MOD;<br />
			cur = cur * i % MOD;<br />
		}<br />
		cout &lt;&lt; ans &lt;&lt; endl;<br />
	}	<br />
	return 0;<br />
}<br />
</pre></code>
        </div>
        <div class="blogfile_showtag">
          <img src="http://pic.yupoo.com/wjh15101051/2380cc18/89ee2c05.png">
          In tag:

          <!--<a href="../tags/blog.html">blog</a>-->
        </div>
      </div>
    </div>
    <div id="middle_nav">
      <div class="blog_host">
        <div class="nav_avator">
          <img src="http://pic.yupoo.com/wjh15101051/72c1aeab/f51d56e0.jpg" alt="avator">
        </div>
        <div class="nav_ID">
          wjh15101051
        </div>
      </div>
      <div class="nav_list">
        <li class="tags">
          <a href="../tags.html">
            <img src="http://pic.yupoo.com/wjh15101051/2380cc18/89ee2c05.png" class="list_icon" id="tags_image">
            Tags
          </a>
        </li>
        <li class="categories">
          <a href="../categories.html">
            <img src="http://pic.yupoo.com/wjh15101051/2ea96b56/7882c4ab.png" class="list_icon" id="categories_image">
            Categories
          </a>
        </li>
        <li class="timeline">
          <a href="../timeline.html">
            <img src="http://pic.yupoo.com/wjh15101051/30365cc7/c1a3be15.png" class="list_icon" id="timeline_image">
            Timeline
          </a>
        </li>
        <li class="about">
          <a href="../about.html">
            <img src="http://pic.yupoo.com/wjh15101051/24f1cb41/e239086e.png" class="list_icon" id="about_image">
            About
          </a>
        </li>
        <li class="toolbox">
          <a href="../toolbox.html">
            <img src="http://pic.yupoo.com/wjh15101051/dee9f673/d3cf682a.png" class="list_icon" id="toolbox_image">
            Toolbox
          </a>
        </li>
        <li class="friends">
            <div class="friends_text">
              <img src="http://pic.yupoo.com/wjh15101051/d291ebed/29f9c807.png" id="friends_image">
              Friends
            </div>
            <div id="fp_friends_list">
              <div id="SGcolin">
                <a href="http://blog.gyx.me/" target="_blank">SGcolin</a>
              </div>
              <div id="Xingcy">
                <a href="https://www.cnblogs.com/xcysblog/" target="_blank">Xingcy</a>
              </div>
              <div id="ZH_comld">
                <a href="https://www.cnblogs.com/ZH-comld/" target="_blank">ZH_comld</a>
              </div>
            </div>
            <br>
          </div>
        </li>
      </div>
    <div class="music_player">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
      <script src="https://blog-static.cnblogs.com/files/yjlaugus/APlayer.min.js"></script>
      <div id="aplayer" class="aplayer"  data-id="5313691453" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
      <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
    </div>
    <div class="bottom">
      <div>
        Copyright © 2020
        <a id="copyright_user_a" href="index.html">
          <span id="copyright_user">wjh15101051</span>
        </a>
      </div>
      <div class="bottom_anime">ღゝ◡╹)ノ♡</div>
    </div>
  </div>
</body>
</html>
