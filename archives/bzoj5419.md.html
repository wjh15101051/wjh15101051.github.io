<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>NOI2018 情报中心</title>
  <link rel="stylesheet" type="text/css" id="frame_style" href="../css/frame_style1.css">
  <link rel="stylesheet" type="text/css" id="Markdown_style" href="../css/Markdown_style.css">
  <script type="text/javascript" src="../jscode/frame.js"></script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="stylesheet" href="https://ziyuan.fenxianglu.cn/js/highlight/styles/default.css">
  <script src="https://ziyuan.fenxianglu.cn/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
</head>
<body>
  <div class="main">
    <div class="head">
      <div class="title1">
        <a href="../index.html">wjh15101051's space</a>
      </div>
      <div class="title2">
        卧薪尝胆，厚积薄发。
      </div>
    </div>
    <div id="middle_blogfile">
      <div class="blog_blogfile">
        <div class="blogfile_title">
            NOI2018 情报中心
        </div>
        <div class="blogfile_stitle">
          <img src="http://pic.yupoo.com/wjh15101051/1e0e1b3a/118165c5.jpg">
          Date: Wed Feb 13 08:15:57 CST 2019
          <img src="http://pic.yupoo.com/wjh15101051/2ea96b56/7882c4ab.png">
          In Category:
          <a href="../categories/NoCategory.html">NoCategory</a>
        </div>
        <div class="blogfile_content">
<div class = "MarkdownCommonContent">
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Description：
</h2>
</div>
<div class = "MarkdownCommonContent">
给一棵树还有树上的若干条链，每条链有权值，边有边权，最大化链并的边权之和减去链的权值和。
</div>
<div class = "MarkdownCommonContent">
$1\leqslant n\leqslant 1000233$
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Solution：
</h2>
</div>
<div class = "MarkdownCommonContent">
分情况讨论，两条链
$LCA$
相同和不同。
</div>
<div class = "MarkdownCommonContent">
先考虑
$LCA$
不同的情况，那么如果他们有交，一定是直上直下的一条链：
</div>
<div class = "MarkdownCommonContent">
<img class = "MarkdownImg" src="https://img-blog.csdn.net/20180810115205431?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0YXJyaWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt="" />
</div>
<div class = "MarkdownCommonContent">
考虑这样对答案的贡献：
$$
res=len[x]+len[y]-val[x]-val[y]-(dist[a]-dist[b=LCA(x)])
$$
那么我们可以把每条链存在他的两个端点，然后从下往上线段树合并，线段树的下标为
$LCA$
的深度，记：
$$
\begin{align}
fir[x]&=len[x]-val[x]\\
sec[x]&=len[x]-val[x]+dist[LCA(x)]
\end{align}
$$
可以在
$dfs$
到
$a$
的时候计算，因此
$dist[a]$
是常数，那么贡献就是：
$$
\begin{align}
res=&\\
&fir[x]+sec[y]&dep[LCA(x)]&lt;dep[LCA(y)]\\
&sec[x]+fir[y]&dep[LCA(x)]&gt;dep[LCA(y)]
\end{align}
$$
由于线段树的下标是
$LCA$
的深度，所以直接左右子树交叉统计答案就可以了。
因为
$a$
和
$b$
不能相等，而线段树的下标又恰好是
$dep[LCA]$
，因此每次清空当前
$dep$
这一位就行了。
</div>
<div class = "MarkdownCommonContent">
再考虑
$LCA$
相同的情况，它们的交形状不再是直上直下的一条链：
</div>
<div class = "MarkdownCommonContent">
<img class = "MarkdownImg" src="https://img-blog.csdn.net/20180810115439851?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0YXJyaWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt="" />
</div>
<div class = "MarkdownCommonContent">
如果我们把
$c$
和
$b$
之间，
$d$
和
$e$
之间的链补满，那么会发现就恰好是链并的两倍。
</div>
<div class = "MarkdownCommonContent">
于是我们把每条链存在两个端点处，那么贡献就是：
$$
\begin{align}
res=&\frac{len[x]+len[y]+dist[c]+dist[d]-2\times dist[a]+dist(d,e)}2-val[x]-val[y]\\
=&\frac{(len[x]-2\times val[x]+dist[c])+(len[y]-2\times val[y]+dist[b])+dist(d,e)}2-dist[a]
\end{align}
$$
那么我们可以枚举点
$a$
，然后发现这其实就是一个
$w[a]+w[b]+dist(a,b)-$
常数的形式，于是像通道那题在第二棵树上所做的那样树形
$DP$
一下就可以了。但是我们还没有要求链的
$LCA$
必须相同，于是我们把所有
$LCA$
相同的链找出来，对每个建虚树就可以了。
</div>
<div class = "MarkdownCommonContent">
因为要求链至少有一个公共边，所以
$dep[LCA]$
必须小于
$dep[a]$
。
</div>
<div class = "MarkdownCommonContent">
<h2 class = "MarkdownH2">
Code：
</h2>
</div>
<div class = "MarkdownCommonContent">
<pre class="MarkdownParaPre"><code class="MarkdownParaCode">
#include&lt;algorithm&gt;<br />
#include&lt;iostream&gt;<br />
#include&lt;cstdlib&gt;<br />
#include&lt;cstdio&gt;<br />
#include&lt;cmath&gt;<br />
#include&lt;cctype&gt;<br />
#include&lt;cstring&gt;<br />
using namespace std;<br />
typedef long long ll;<br />
inline ll rd()<br />
{<br />
	register ll res = 0,f = 1;register char c = getchar();<br />
	while(!isdigit(c)){if(c == '-')f = -1;c = getchar();}<br />
	while(isdigit(c)){res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - '0';c = getchar();}<br />
	return res * f;<br />
}<br />
int n,m;<br />
#define MAXN 50010<br />
#define MAXM 100010<br />
struct edge{int to,nxt,v;}e[MAXN &lt;&lt; 1];<br />
int edgenum = 0,lin[MAXN] = {0};<br />
void add(int a,int b,int c)<br />
{<br />
	e[++edgenum] = (edge){b,lin[a],c};lin[a] = edgenum;<br />
	e[++edgenum] = (edge){a,lin[b],c};lin[b] = edgenum;<br />
	return;<br />
}<br />
ll d[MAXN];<br />
int top[MAXN],dep[MAXN],son[MAXN],siz[MAXN],fa[MAXN],rnk[MAXN],tot = 0;<br />
void dfs1(int k,int depth)<br />
{<br />
	dep[k] = depth;siz[k] = 1;<br />
	for(int i = lin[k];i != 0;i = e[i].nxt)<br />
	{<br />
		if(e[i].to == fa[k])continue;<br />
		d[e[i].to] = d[k] + e[i].v;fa[e[i].to] = k;<br />
		dfs1(e[i].to,depth + 1);siz[k] += siz[e[i].to];<br />
		if(son[k] == 0 || siz[e[i].to] &gt; siz[son[k]])son[k] = e[i].to;<br />
	}<br />
	return;<br />
}<br />
void dfs2(int k,int tp)<br />
{<br />
	top[k] = tp;rnk[k] = ++tot;<br />
	if(son[k] == 0)return;<br />
	dfs2(son[k],tp);<br />
	for(int i = lin[k];i != 0;i = e[i].nxt)<br />
		if(e[i].to != fa[k] && e[i].to != son[k])dfs2(e[i].to,e[i].to);<br />
	return;<br />
}<br />
int LCA(int a,int b)<br />
{<br />
	while(top[a] != top[b]){if(dep[top[a]] &lt; dep[top[b]])swap(a,b);a = fa[top[a]];}<br />
	return (dep[a] &lt; dep[b] ? a : b);<br />
}<br />
ll dis(int a,int b){return d[a] + d[b] - 2 * d[LCA(a,b)];}<br />
struct chain{int a,b,lca;ll l,v,fir,sec;}s[MAXM];<br />
#define INF 0x3f3f3f3f3f3f3f3f<br />
ll ans = -INF;<br />
namespace SOLVE1<br />
{<br />
	struct node{int lc,rc;ll fir,sec;node(){fir = sec = -INF;}}t[MAXN * 60];<br />
	int ptr = 0;<br />
	int newnode(){int k = ++ptr;t[k].lc = t[k].rc = 0;t[k].fir = t[k].sec = -INF;return k;}<br />
	int root[MAXN];<br />
	#define mid ((l + r) &gt;&gt; 1)<br />
	void insert(int &rt,int p,ll fir,ll sec,ll v,int l,int r)<br />
	{<br />
		if(rt == 0)rt = newnode();<br />
		if(l == r){t[rt].fir = max(t[rt].fir,fir);t[rt].sec = max(t[rt].sec,sec);return;}<br />
		if(p &lt;= mid)insert(t[rt].lc,p,fir,sec,v,l,mid);<br />
		else insert(t[rt].rc,p,fir,sec,v,mid + 1,r);<br />
		ans = max(ans,t[t[rt].lc].fir + t[t[rt].rc].sec - v);<br />
		t[rt].fir = max(t[t[rt].lc].fir,t[t[rt].rc].fir);<br />
		t[rt].sec = max(t[t[rt].lc].sec,t[t[rt].rc].sec);<br />
		return;<br />
	}<br />
	int merge(int x,int y,ll v)<br />
	{<br />
		if(x == 0 || y == 0)return x + y;<br />
		ans = max(ans,t[t[x].lc].fir + t[t[y].rc].sec - v);<br />
		ans = max(ans,t[t[x].rc].sec + t[t[y].lc].fir - v);<br />
		t[x].fir = max(t[x].fir,t[y].fir);t[x].sec = max(t[x].sec,t[y].sec);<br />
		t[x].lc = merge(t[x].lc,t[y].lc,v);t[x].rc = merge(t[x].rc,t[y].rc,v);<br />
		return x;<br />
	}<br />
	void reset(int rt,int p,int l,int r)<br />
	{<br />
		if(rt == 0)return;<br />
		if(l == r){t[rt].fir = t[rt].sec = -INF;return;}<br />
		if(p &lt;= mid)reset(t[rt].lc,p,l,mid);<br />
		else reset(t[rt].rc,p,mid + 1,r);<br />
		t[rt].fir = max(t[t[rt].lc].fir,t[t[rt].rc].fir);<br />
		t[rt].sec = max(t[t[rt].lc].sec,t[t[rt].rc].sec);<br />
		return;<br />
	}<br />
	void dfs(int k,int fa)<br />
	{<br />
		reset(root[k],dep[k],1,n);<br />
		for(int i = lin[k];i != 0;i = e[i].nxt)if(e[i].to != fa){dfs(e[i].to,k);reset(root[e[i].to],dep[k],1,n);}<br />
		for(int i = lin[k];i != 0;i = e[i].nxt)if(e[i].to != fa)root[k] = merge(root[k],root[e[i].to],d[k]);<br />
		return;<br />
	}<br />
	void solve()<br />
	{<br />
		ptr = 0;<br />
		for(int i = 1;i &lt;= n;++i)root[i] = 0;<br />
		for(int i = 1;i &lt;= m;++i)<br />
		{<br />
			if(s[i].a != s[i].lca)insert(root[s[i].a],dep[s[i].lca],s[i].fir,s[i].sec,d[s[i].a],1,n);<br />
			if(s[i].b != s[i].lca)insert(root[s[i].b],dep[s[i].lca],s[i].fir,s[i].sec,d[s[i].b],1,n);<br />
		}<br />
		dfs(1,0);<br />
		return;<br />
	}<br />
}<br />
namespace SOLVE2<br />
{<br />
	struct query{int id,nxt;}q[MAXM];<br />
	int head[MAXN] = {0},qnum = 0;<br />
	void addq(int p,int a){q[++qnum] = (query){a,head[p]};head[p] = qnum;return;}<br />
	int v[MAXN];<br />
	struct dat<br />
	{<br />
		ll w;int i;<br />
		dat(ll w_ = 0,int i_ = 0){w = w_;i = i_;}<br />
		void init(){w = i = 0;}<br />
	};<br />
	pair&lt;dat,dat&gt; f[MAXN];<br />
	ll calc(dat a,dat b){if(a.i == 0 || b.i == 0)return -INF;else return a.w + b.w + dis(a.i,b.i);}<br />
	#define fi first<br />
	#define se second<br />
	void insert(pair&lt;dat,dat&gt; &f,dat k)<br />
	{<br />
		if(f.fi.i == 0){f.fi = k;return;}if(f.se.i == 0){f.se = k;return;}<br />
		pair&lt;dat,dat&gt; res = f;<br />
		if(calc(f.fi,k) &gt; calc(res.fi,res.se))res = make_pair(f.fi,k);<br />
		if(calc(f.se,k) &gt; calc(res.fi,res.se))res = make_pair(f.se,k);<br />
		f = res;<br />
		return;<br />
	}<br />
	pair&lt;dat,dat&gt; merge(pair&lt;dat,dat&gt; a,pair&lt;dat,dat&gt; b)<br />
	{<br />
		if(a.fi.i == 0)return b;if(b.fi.i == 0)return a;<br />
		ll v = -INF,l;pair&lt;dat,dat&gt; res;<br />
		if((l = calc(a.fi,a.se)) &gt; v)res = make_pair(a.fi,a.se),v = l;<br />
		if((l = calc(b.fi,b.se)) &gt; v)res = make_pair(b.fi,b.se),v = l;<br />
		if((l = calc(a.fi,b.fi)) &gt; v)res = make_pair(a.fi,b.fi),v = l;<br />
		if((l = calc(a.fi,b.se)) &gt; v)res = make_pair(a.fi,b.se),v = l;<br />
		if((l = calc(a.se,b.fi)) &gt; v)res = make_pair(a.se,b.fi),v = l;<br />
		if((l = calc(a.se,b.se)) &gt; v)res = make_pair(a.se,b.se),v = l;<br />
		return res;<br />
	}<br />
	ll calc(pair&lt;dat,dat&gt; a,pair&lt;dat,dat&gt; b)<br />
	{<br />
		ll v = -INF,l;<br />
		if((l = calc(a.fi,b.fi)) &gt; v)v = l;<br />
		if((l = calc(a.fi,b.se)) &gt; v)v = l;<br />
		if((l = calc(a.se,b.fi)) &gt; v)v = l;<br />
		if((l = calc(a.se,b.se)) &gt; v)v = l;<br />
		return v;<br />
	}<br />
	int p[MAXM * 2];<br />
	bool cmp_rnk(int a,int b){return rnk[a] &lt; rnk[b];}<br />
	int stack[MAXN],top = 0;<br />
	int cursolve;<br />
	struct edge{int to,nxt;}e[MAXN];<br />
	int lin[MAXN] = {0},edgenum;<br />
	void add(int a,int b){e[++edgenum] = (edge){b,lin[a]};lin[a] = edgenum;return;}<br />
	int t[MAXN];<br />
	void dp(int k)<br />
	{<br />
		t[++t[0]] = k;ll tp = ans;<br />
		if(f[k].se.i != 0 && k != cursolve)ans = max(ans,calc(f[k].fi,f[k].se) / 2 - d[k]);<br />
		for(int i = lin[k];i != 0;i = e[i].nxt)<br />
		{<br />
			dp(e[i].to);<br />
			if(k != cursolve)ans = max(ans,calc(f[k],f[e[i].to]) / 2 - d[k]);<br />
			f[k] = merge(f[k],f[e[i].to]);<br />
		}<br />
		return;<br />
	}<br />
	void solve(int k)<br />
	{<br />
		t[0] = 0;<br />
		cursolve = k;p[0] = 0;<br />
		int cnt = 0;<br />
		for(int i = head[k];i != 0;i = q[i].nxt)++cnt;<br />
		if(cnt == 0 || cnt == 1)return;<br />
		for(int i = head[k];i != 0;i = q[i].nxt)<br />
		{<br />
			int v = q[i].id;<br />
			insert(f[s[v].a],(dat){d[s[v].a] + s[v].l - 2 * s[v].v,s[v].b});<br />
			insert(f[s[v].b],(dat){d[s[v].b] + s[v].l - 2 * s[v].v,s[v].a});<br />
			p[++p[0]] = s[v].a;p[++p[0]] = s[v].b;<br />
		}<br />
		sort(p + 1,p + 1 + p[0]);p[0] = unique(p + 1,p + 1 + p[0]) - p - 1;<br />
		sort(p + 1,p + 1 + p[0],cmp_rnk);<br />
		top = 0;stack[++top] = p[1];<br />
		for(int i = 2;i &lt;= p[0];++i)<br />
		{<br />
			int lca = LCA(p[i],stack[top]);<br />
			if(lca == stack[top]){stack[++top] = p[i];continue;}<br />
			while(top &gt;= 2)<br />
			{<br />
				if(rnk[lca] &lt; rnk[stack[top - 1]])add(stack[top - 1],stack[top]),--top;<br />
				else{add(lca,stack[top]);--top;break;}<br />
			}<br />
			if(top == 1 && rnk[lca] &lt; rnk[stack[top]]){add(lca,stack[top]);stack[top] = lca;}<br />
			if(stack[top] != lca)stack[++top] = lca;stack[++top] = p[i];<br />
		}<br />
		while(top &gt;= 2){add(stack[top - 1],stack[top]);--top;}<br />
		dp(stack[1]);<br />
		for(int i = 1;i &lt;= t[0];++i)f[t[i]].fi.init(),f[t[i]].se.init();<br />
		edgenum = 0;for(int i = 1;i &lt;= t[0];++i)lin[t[i]] = 0;<br />
		return;<br />
	}<br />
	void solve()<br />
	{<br />
		for(int i = 1;i &lt;= n;++i)head[i] = 0;<br />
		qnum = 0;<br />
		for(int i = 1;i &lt;= m;++i)if(s[i].a != s[i].b)addq(s[i].lca,i);<br />
		for(int i = 1;i &lt;= n;++i)solve(i);<br />
		return;<br />
	}<br />
}<br />
void work()<br />
{<br />
	scanf("%d",&n);<br />
	edgenum = 0;<br />
	for(int i = 1;i &lt;= n;++i)son[i] = lin[i] = 0;<br />
	int a,b,c;<br />
	for(int i = 1;i &lt; n;++i){a = rd();b = rd();c = rd();add(a,b,c);}<br />
	dfs1(1,1);dfs2(1,1);<br />
	scanf("%d",&m);<br />
	for(int i = 1;i &lt;= m;++i)<br />
	{<br />
		s[i].a = rd();s[i].b = rd();s[i].v = rd();<br />
		s[i].lca = LCA(s[i].a,s[i].b);s[i].l = d[s[i].a] + d[s[i].b] - 2 * d[s[i].lca];<br />
		s[i].fir = s[i].l - s[i].v;s[i].sec = s[i].l - s[i].v + d[s[i].lca];<br />
	}<br />
	ans = -INF;<br />
	SOLVE1::solve();SOLVE2::solve();<br />
	if(ans &gt;= -0x3f3f3f3f3f3f3f3f / 2)printf("%lld\n",ans);<br />
	else puts("F");<br />
	return;<br />
}<br />
int main()<br />
{<br />
	int testcases;<br />
	scanf("%d",&testcases);<br />
	while(testcases--)work();<br />
	return 0;<br />
}<br />
</pre></code>
</div>
        </div>
        <div class="blogfile_showtag">
          <img src="http://pic.yupoo.com/wjh15101051/2380cc18/89ee2c05.png">
          In tag:
<a href="../tags/数据结构-线段树合并.html">数据结构-线段树合并</a> 
          <!--<a href="../tags/blog.html">blog</a>-->
        </div>
      </div>
    </div>
    <div id="middle_nav">
      <div class="blog_host">
        <div class="nav_avator">
          <img src="http://pic.yupoo.com/wjh15101051/72c1aeab/f51d56e0.jpg" alt="avator">
        </div>
        <div class="nav_ID">
          wjh15101051
        </div>
      </div>
      <div class="nav_list">
        <li class="tags">
          <a href="../tags.html">
            <img src="http://pic.yupoo.com/wjh15101051/2380cc18/89ee2c05.png" class="list_icon" id="tags_image">
            Tags
          </a>
        </li>
        <li class="categories">
          <a href="../categories.html">
            <img src="http://pic.yupoo.com/wjh15101051/2ea96b56/7882c4ab.png" class="list_icon" id="categories_image">
            Categories
          </a>
        </li>
        <li class="timeline">
          <a href="../timeline.html">
            <img src="http://pic.yupoo.com/wjh15101051/30365cc7/c1a3be15.png" class="list_icon" id="timeline_image">
            Timeline
          </a>
        </li>
        <li class="about">
          <a href="../about.html">
            <img src="http://pic.yupoo.com/wjh15101051/24f1cb41/e239086e.png" class="list_icon" id="about_image">
            About
          </a>
        </li>
        <li class="toolbox">
          <a href="../toolbox.html">
            <img src="http://pic.yupoo.com/wjh15101051/dee9f673/d3cf682a.png" class="list_icon" id="toolbox_image">
            Toolbox
          </a>
        </li>
        <li class="friends">
            <div class="friends_text">
              <img src="http://pic.yupoo.com/wjh15101051/d291ebed/29f9c807.png" id="friends_image">
              Friends
            </div>
            <div id="fp_friends_list">
              <div id="SGcolin">
                <a href="http://blog.gyx.me/" target="_blank">SGcolin</a>
              </div>
              <div id="Xingcy">
                <a href="https://www.cnblogs.com/xcysblog/" target="_blank">Xingcy</a>
              </div>
              <div id="ZH_comld">
                <a href="https://www.cnblogs.com/ZH-comld/" target="_blank">ZH_comld</a>
              </div>
            </div>
            <br>
          </div>
        </li>
      </div>
    <div class="music_player">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
      <script src="https://blog-static.cnblogs.com/files/yjlaugus/APlayer.min.js"></script>
      <div id="aplayer" class="aplayer"  data-id="5313691453" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
      <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
    </div>
    <div class="bottom">
      <div>
        Copyright © 2020
        <a id="copyright_user_a" href="index.html">
          <span id="copyright_user">wjh15101051</span>
        </a>
      </div>
      <div class="bottom_anime">ღゝ◡╹)ノ♡</div>
    </div>
  </div>
</body>
</html>
